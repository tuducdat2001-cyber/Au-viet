<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Qu·∫£n l√Ω ƒë∆°n h√†ng SPEEGO</title>
    <style>
        :root {
            --filter-row-height: 38px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            margin: 0;
            user-select: none;
        }

        /* --- M·ªöI: CSS CHO HEADER H√åNH ·∫¢NH --- */
        .main-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .main-header img {
            max-width: 100%;
            height: auto;
            max-height: 60px;
            /* Gi·ªõi h·∫°n chi·ªÅu cao c·ªßa ·∫£nh */
        }

        /* --- K·∫æT TH√öC CSS HEADER --- */


        h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .main-filters {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }

        .filter-group select,
        .filter-group input {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
        }

        /* Th√™m style cho dropdown trong b·∫£ng */
        td select.editable-select {
            width: 100%;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: inherit;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        td.editable-dropdown-cell {
            padding: 0;
            /* X√≥a padding c·ªßa td ƒë·ªÉ select chi·∫øm to√†n b·ªô */
        }

        td.editable-dropdown-cell select.editable-select {
            padding: 8px 12px;
            /* Di chuy·ªÉn padding v√†o select */
        }

        .tab-container {
            margin-bottom: 15px;
            padding: 5px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tab-btn {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            background-color: #dfe6e9;
        }

        .tab-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
            font-weight: bold;
        }

        .tab-btn.tracking-tab {
            background-color: #e74c3c;
            color: white;
        }

        .tab-btn.tracking-tab.active {
            background-color: #c0392b;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            align-items: center;
            background: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .controls>div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-wrapper {
            position: relative;
            overflow: auto;
            max-height: 65vh;
            background: white;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 1900px;
            font-size: 14px;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th,
        td {
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            text-align: left;
            white-space: nowrap;
            background-color: white;
        }

        th {
            background-color: #3498db;
            color: white;
            top: var(--filter-row-height);
            z-index: 20;
            font-weight: 500;
        }

        #filterRow th {
            top: 0;
            background-color: #f2f6fa;
            padding: 4px 8px;
        }

        .filter-input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
        }

        .dual-filter-container {
            display: flex;
            gap: 4px;
            align-items: center;
            flex-direction: column;
        }

        .dual-filter-container input {
            flex: 1;
            min-width: 0;
        }

        td.editable {
            background-color: #fffbe8;
        }

        button {
            padding: 6px 12px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
            color: white;
        }

        #downloadExcel {
            background-color: #16a085;
        }

        #downloadExcel:hover {
            background-color: #1abc9c;
        }

        #updateAll {
            position: relative;
        }

        .highlight {
            background-color: #ffeb3b !important;
        }

        .no-data {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }

        .refresh-btn {
            background-color: #2ecc71;
        }

        .refresh-btn:hover {
            background-color: #27ae60;
        }

        .refresh-icon {
            margin-right: 5px;
        }

        .fixed-column {
            position: sticky;
            z-index: 5;
            background-color: #f8f9fa;
            /* slightly different bg for fixed columns */
        }

        th.fixed-column {
            z-index: 30;
            background-color: #3498db;
        }

        #filterRow th.fixed-column {
            z-index: 40;
            background-color: #e9ecef;
            /* slightly different bg for fixed filter columns */
        }

        td.fixed-column {
            background-color: white;
        }

        .date-input {
            border: none;
            background: transparent;
            width: 'fit-content';
            font-family: inherit;
            font-size: inherit;
            user-select: text;
        }

        .note-highlight {
            background-color: #fff2a8;
        }

        .status-ok {
            background-color: #d4edda;
            color: #155724;
            font-weight: bold;
        }

        .status-cancel {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }

        td.cell-selected {
            background-color: rgba(52, 152, 219, 0.4) !important;
        }

        td.paste-anchor {
            outline: 2px solid #e74c3c !important;
            outline-offset: -2px;
        }

        .order-counter {
            margin-left: 15px;
            font-weight: bold;
            font-size: 14px;
            color: #2c3e50;
        }

        .order-counter b {
            color: #e74c3c;
            font-size: 16px;
            padding: 0 4px;
        }

        .selection-summary {
            margin-left: 20px;
            font-size: 14px;
            color: #2980b9;
            font-weight: 500;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .selection-summary .summary-item {
            display: inline-block;
            background-color: #ecf0f1;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
        }

        .selection-summary b {
            color: #c0392b;
            padding-left: 5px;
        }

        /* Thay th·∫ø custom alert styles b·∫±ng toast styles */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
        }

        .toast {
            background: white;
            padding: 12px 16px;
            margin-bottom: 10px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            min-width: 200px;
            transform: translateX(400px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            pointer-events: auto;
            border-left: 4px solid #3498db;
            font-size: 14px;
            color: #333;
            position: relative;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.info {
            border-left-color: #3498db;
        }

        .toast.success {
            border-left-color: #2ecc71;
            background: #f8fff9;
        }

        .toast.error {
            border-left-color: #e74c3c;
            background: #fff8f8;
        }

        .toast-close {
            position: absolute;
            top: 4px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            color: #999;
            cursor: pointer;
            padding: 2px 4px;
            line-height: 1;
        }

        .toast-close:hover {
            color: #666;
        }

        /* X√≥a c√°c styles c≈© c·ªßa custom alert */
        .custom-alert-overlay,
        .custom-alert-box,
        #customAlertMessage,
        .custom-alert-close-btn {
            display: none !important;
        }

        /* Pagination styles */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            gap: 10px;
        }

        .pagination-controls button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .pagination-controls button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        .pagination-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 14px;
            color: #555;
            font-weight: 500;
        }

        .pagination-page-size {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pagination-page-size label {
            font-size: 13px;
            color: #555;
        }

        .pagination-page-size select {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 13px;
        }

        /* --- M·ªöI: CSS CHO POPOVER ƒê·ªíNG B·ªò --- */
        .popover-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1050;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .popover-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .popover-header {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popover-header h4 {
            margin: 0;
            font-size: 18px;
        }

        .popover-close {
            border: none;
            background: none;
            font-size: 24px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }

        .popover-body {
            padding: 20px;
            overflow-y: auto;
        }

        .popover-body h5 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #3498db;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }

        .popover-body .no-changes {
            color: #7f8c8d;
            font-style: italic;
        }

        .popover-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .popover-table th,
        .popover-table td {
            border: 1px solid #ddd;
            padding: 6px 10px;
            text-align: left;
        }

        .popover-table td .old-value {
            text-decoration: line-through;
            color: #e74c3c;
            margin-right: 8px;
        }

        .popover-table td .new-value {
            font-weight: bold;
            color: #27ae60;
        }

        .popover-footer {
            padding: 15px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        #syncChangesBtn {
            background-color: #f39c12;
            position: relative;
        }

        #syncChangesBtn:hover {
            background-color: #e67e22;
        }

        .changes-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #e74c3c;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
            line-height: 14px;
            display: none;
            /* Hidden by default */
        }

        /* --- M·ªöI: CSS CHO B·ªò L·ªåC MULTI-SELECT TRONG B·∫¢NG --- */
        .multiselect-filter {
            position: relative;
            width: 100%;
        }

        /* --- M·ªöI: CSS RI√äNG CHO B·ªò L·ªåC MULTI-SELECT CH√çNH --- */
        .main-multiselect-filter {
            position: relative;
            width: 100%;
        }

        .multiselect-display-main {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
            width: 100%;
            min-width: 180px;
            text-align: left;
            background-color: white;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .multiselect-display-main:hover {
            border-color: #888;
        }

        /* --- K·∫æT TH√öC CSS B·ªò L·ªåC CH√çNH --- */


        .multiselect-display {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: white;
            font-size: 13px;
            cursor: pointer;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #8b8686;
        }

        .multiselect-dropdown {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
            width: 250px;
            /* TƒÉng ƒë·ªô r·ªông dropdown */
            max-height: 300px;
            /* TƒÉng chi·ªÅu cao */
            overflow-y: auto;
            z-index: 150;
            /* TƒÉng z-index ƒë·ªÉ n·ªïi l√™n tr√™n */
            margin-top: 2px;
        }

        .multiselect-dropdown.show {
            display: block;
        }

        .multiselect-item {
            display: block;
            padding: 8px 12px;
            /* TƒÉng padding */
            cursor: pointer;
            font-size: 14px;
            /* TƒÉng font-size */
            color: #333;
            border-bottom: 1px solid #f0f0f0;
            /* Th√™m ƒë∆∞·ªùng k·∫ª */
        }

        .multiselect-item:last-child {
            border-bottom: none;
        }


        .multiselect-item:hover {
            background-color: #f0f0f0;
        }

        .multiselect-item input {
            margin-right: 8px;
            vertical-align: middle;
        }

        .multiselect-item label {
            vertical-align: middle;
            cursor: pointer;
        }

        #clearFiltersBtn {
            transition: all 0.3s ease;
        }

        #clearFiltersBtn:hover {
            background-color: #c0392b !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #clearFiltersBtn:active {
            transform: translateY(0);
        }

        /* Khung ph·ªß n·ªÅn */
        .popup {
            display: none; /* ·∫®n m·∫∑c ƒë·ªãnh */
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4); /* n·ªÅn m·ªù */
        }

        /* N·ªôi dung popup */
        .popup-content {
            background: #fff;
            margin: 15% auto;
            padding: 20px;
            width: 700px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* N√∫t ƒë√≥ng */
        .close {
            float: right;
            font-size: 24px;
            cursor: pointer;
        }

        /* B·∫£ng */
        .table-wrap { border:1px solid #eee; border-radius:12px; overflow:hidden; }
        .table {
            width:100%; border-collapse:separate; border-spacing:0; font-size:14px;
        }
        .table thead th {
            position:sticky; top:0; background:#f7f8fa; z-index:1;
            text-align:left; padding:12px 14px; font-weight:600; border-bottom:1px solid #eceff3;
        }
        .table tbody td { padding:10px 14px; border-bottom:1px solid #f1f3f6; }
        .table tbody tr:nth-child(odd) { background:#fcfdff; }
        .badge-old { color:#c0392b; font-weight:600; }
        .badge-new { color:#2e7d32; font-weight:700; }
        .row-changed { background:#fff9e6; } /* t√¥ nh·∫π n·∫øu c√≥ ch√™nh l·ªách */
        .empty-state {
            padding:16px; text-align:center; color:#666; border:1px dashed #ddd; border-radius:10px;
        }
    </style>
</head>

<body>
    <!-- M·ªöI: Header s·ª≠ d·ª•ng h√¨nh ·∫£nh -->
    <div class="main-header">
        <img src="https://www.appsheet.com/template/gettablefileurl?appName=Appsheet-325045268&tableName=Kho%20%E1%BA%A3nh&fileName=Kho%20%E1%BA%A3nh_Images%2Fbe61f44f.%E1%BA%A2nh.021347.png"
            alt="SPEEGO Header">
        <h2>Qu·∫£n l√Ω ƒë∆°n h√†ng SPEEGO</h2>
    </div>


    <div id="mainFilters" class="main-filters">
        <!-- THAY ƒê·ªîI: B·ªô l·ªçc Th·ªã tr∆∞·ªùng ƒëa l·ª±a ch·ªçn -->
        <div class="filter-group">
            <label for="filterMarketDisplay">Th·ªã tr∆∞·ªùng</label>
            <div class="main-multiselect-filter">
                <button id="filterMarketDisplay" class="multiselect-display-main">T·∫•t c·∫£ Th·ªã tr∆∞·ªùng</button>
                <div id="filterMarketDropdown" class="multiselect-dropdown"></div>
            </div>
        </div>
        <!-- THAY ƒê·ªîI: B·ªô l·ªçc S·∫£n ph·∫©m ƒëa l·ª±a ch·ªçn -->
        <div class="filter-group">
            <label for="filterProductDisplay">S·∫£n ph·∫©m</label>
            <div class="main-multiselect-filter">
                <button id="filterProductDisplay" class="multiselect-display-main">T·∫•t c·∫£ S·∫£n ph·∫©m</button>
                <div id="filterProductDropdown" class="multiselect-dropdown"></div>
            </div>
        </div>
        <div class="filter-group">
            <label for="filterDateFrom">T·ª´ ng√†y l√™n ƒë∆°n</label>
            <input type="date" id="filterDateFrom">
        </div>
        <div class="filter-group">
            <label for="filterDateTo">T·ªõi ng√†y l√™n ƒë∆°n</label>
            <input type="date" id="filterDateTo">
        </div>
        <div class="filter-group">
            <label for="fixedColumns">S·ªë c·ªôt c·ªë ƒë·ªãnh</label>
            <input type="number" id="fixedColumns" value="1" min="0" style="width: 60px;">
        </div>
        <div class="filter-group">
            <label>&nbsp;</label>
            <button id="clearFiltersBtn"
                style="padding: 6px 12px; border-radius: 4px; border: 1px solid #e74c3c; background-color: #e74c3c; color: white; cursor: pointer; font-size: 14px;">
                üóëÔ∏è X√≥a l·ªçc
            </button>
        </div>
    </div>

    <div id="tabContainer" class="tab-container"></div>

    <div class="controls">
        <div>
            <button id="refreshData" class="refresh-btn">
                <span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu
            </button>
            <!-- M·ªöI: N√∫t ƒë·ªìng b·ªô -->
            <button id="syncChangesBtn">
                Tr·∫°ng th√°i thay ƒë·ªïi
                <span id="changesBadge" class="changes-badge">0</span>
            </button>
            <button id="updateAll">C·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi</button>
            <button id="downloadExcel">T·∫£i Excel</button>
            <span id="orderCounter" class="order-counter"></span>
            <span id="selectionSummary" class="selection-summary"></span>
        </div>
        <div>
            <button id="toggleOrderErrorView" class="tab-btn tracking-tab">Xem ƒë∆°n c·∫≠p nh·∫≠t l·ªói</button>
            <button id="toggleTrackingView" class="tab-btn tracking-tab">Xem ƒë∆°n c√≥ m√£ Tracking</button>
            <!-- N√öT M·ªöI -->
            <button id="toggleDuplicateTrackingView" class="tab-btn tracking-tab">Xem ƒë∆°n tr√πng M√£ tracking</button>
            <button id="transferWarehouseBtn" class="tab-btn" disabled
                style="display: none; background-color: #f39c12; color: white;">Chuy·ªÉn kho</button>
        </div>
    </div>

    <div class="table-wrapper" id="tableContainer">
        <table>
            <thead>
                <tr id="filterRow"></tr>
                <tr>
                    <th>M√£ ƒë∆°n h√†ng</th>
                    <th>Ng√†y l√™n ƒë∆°n</th>
                    <th>Name*</th>
                    <th>Phone*</th>
                    <th>Add</th>
                    <th>City</th>
                    <th>State</th>
                    <th>Khu v·ª±c</th>
                    <th>Zipcode</th>
                    <th>M·∫∑t h√†ng</th>
                    <th>T√™n m·∫∑t h√†ng 1</th>
                    <th>S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1</th>
                    <th>T√™n m·∫∑t h√†ng 2</th>
                    <th>S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2</th>
                    <th>Qu√† t·∫∑ng</th>
                    <th>S·ªë l∆∞·ª£ng qu√† k√®m</th>
                    <th>Gi√° b√°n</th>
                    <th>Lo·∫°i ti·ªÅn thanh to√°n</th>
                    <th>T·ªïng ti·ªÅn VNƒê</th>
                    <th>H√¨nh th·ª©c thanh to√°n</th>
                    <th>Ghi ch√∫</th>
                    <th>Ghi ch√∫ v·∫≠n ƒë∆°n</th>
                    <th>K·∫øt qu·∫£ check</th>
                    <th>M√£ Tracking</th>
                    <th>Ng√†y ƒë√≥ng h√†ng</th>
                    <th>Tr·∫°ng th√°i giao h√†ng</th>
                    <th>GHI CH√ö</th>
                    <th>Th·ªùi gian giao d·ª± ki·∫øn</th>
                    <th>Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2</th>
                    <th>Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)</th>
                    <th>Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <div id="paginationControls" class="pagination-controls">
        <button id="prevPage">Trang tr∆∞·ªõc</button>
        <span id="pageInfo" class="pagination-info">Trang 1/1</span>
        <button id="nextPage">Trang sau</button>
        <div class="pagination-page-size">
            <label for="rowsPerPageSelect">S·ªë d√≤ng/trang:</label>
            <select id="rowsPerPageSelect">
                <option value="50">50</option>
                <option value="70" selected>70</option>
                <option value="100">100</option>
                <option value="200">200</option>
                <option value="500">500</option>
            </select>
        </div>
    </div>

    <div id="toastContainer" class="toast-container"></div>

    <!-- M·ªöI: HTML CHO POPOVER ƒê·ªíNG B·ªò -->
    <div id="syncPopover" class="popover-overlay">
        <div class="popover-container">
            <div class="popover-header">
                <h4>Qu·∫£n l√Ω c√°c thay ƒë·ªïi ƒëang ch·ªù</h4>
                <button id="closePopoverBtn" class="popover-close">&times;</button>
            </div>
            <div id="popoverBody" class="popover-body">
                <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c t·∫°o b·ªüi JavaScript -->
            </div>
            <div class="popover-footer">
                <button id="discardAllChangesBtn" style="background-color: #e74c3c;">H·ªßy b·ªè t·∫•t c·∫£</button>
                <button id="applyAllChangesBtn" style="background-color: #2ecc71;">L∆∞u t·∫•t c·∫£</button>
            </div>
        </div>
    </div>

    <!-- Popup -->
    <div id="popup" class="popup">
    <div class="popup-content">
        <span id="closePopup" class="close">&times;</span>
        <h2>ƒê∆°n c·∫≠p nh·∫≠t l·ªói</h2>
        <div id="popupTableContainer" style="max-height: 400px; overflow-y: auto; margin-top: 15px;">
            
        </div>

        <div class="popup-footer" style="margin-top: 20px; text-align: right;">
            <button id="clearErrorOrdersBtn" style="background-color: #e74c3c; margin-right: 10px;">X√≥a ƒë∆°n l·ªói</button>
            <button id="updateErrorOrdersBtn" style="background-color: #2ecc71;">C·∫≠p nh·∫≠t l·∫°i ƒë∆°n l·ªói</button>
        </div>
    </div>


    <script>
        const prod = 'https://n-api-gamma.vercel.app'
        const localhost = 'http://localhost:8081'
        const host = 'prod'
        const mainHost = host === 'prod' ? prod : localhost
        const SHEET_NAME = 'F3';
        const BATCH_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update?verbose=true`;
        const SINGLE_UPDATE_API_URL = `${mainHost}/sheet/${SHEET_NAME}/update-single`;
        const TRANSFER_API_URL = `${mainHost}/sheet/MGT n·ªôi b·ªô/rows/batch`;
        const MGT_NOI_BO_ORDER_API_URL = `${mainHost}/sheet/MGT n·ªôi b·ªô/data`;

        const TEAM_COLUMN_NAME = "Team";
        const PRIMARY_KEY_COLUMN = "M√£ ƒë∆°n h√†ng";

        const displayColumns = ["M√£ ƒë∆°n h√†ng", "Ng√†y l√™n ƒë∆°n", "Name*", "Phone*", "Add", "City", "State", "Khu v·ª±c", "Zipcode", "M·∫∑t h√†ng", "T√™n m·∫∑t h√†ng 1", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 1", "T√™n m·∫∑t h√†ng 2", "S·ªë l∆∞·ª£ng m·∫∑t h√†ng 2", "Qu√† t·∫∑ng", "S·ªë l∆∞·ª£ng qu√† k√®m", "Gi√° b√°n", "Lo·∫°i ti·ªÅn thanh to√°n", "T·ªïng ti·ªÅn VNƒê", "H√¨nh th·ª©c thanh to√°n", "Ghi ch√∫", "Ghi ch√∫ v·∫≠n ƒë∆°n", "K·∫øt qu·∫£ check", "M√£ Tracking", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "GHI CH√ö", "Th·ªùi gian giao d·ª± ki·∫øn", "Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)"];
        const columnMapping = { "Ghi ch√∫ v·∫≠n ƒë∆°n": "ng√†y h·∫πn ƒë·∫©y ƒë∆°n", "K·∫øt qu·∫£ check": "K·∫øt qu·∫£ Check" };

        const editableCols = ["K·∫øt qu·∫£ check", "M√£ Tracking", "Ng√†y ƒë√≥ng h√†ng", "Tr·∫°ng th√°i giao h√†ng", "Th·ªùi gian giao d·ª± ki·∫øn", "Ph√≠ ship n·ªôi ƒë·ªãa M·ªπ (usd)", "Ph√≠ x·ª≠ l√Ω ƒë∆°n ƒë√≥ng h√†ng-L∆∞u kho(usd)", "GHI CH√ö"];
        const checkStatusOptions = ["", "OK", "Hu·ª∑", "Ch·ªù check l·∫°i", "Sai SƒêT", "Sai ƒë·ªãa ch·ªâ", "Kh√°c"];


        // ===== STATE MANAGEMENT REFACTORED =====
        let state = {
            allData: [],
            // S·ª¨A ƒê·ªîI: T√°ch th√†nh 2 lo·∫°i thay ƒë·ªïi
            legacyChanges: new Map(),      // Thay ƒë·ªïi t·ª´ phi√™n tr∆∞·ªõc, ƒë·ªçc t·ª´ localStorage
            pendingChanges: new Map(),     // Thay ƒë·ªïi trong phi√™n l√†m vi·ªác hi·ªán t·∫°i
            activeTeam: 'all',
            showTrackingOrders: false,
            showDuplicateTrackingOrders: false, // <-- STATE M·ªöI
            filterValues: {
                // S·ª¨A ƒê·ªîI: Kh·ªüi t·∫°o gi√° tr·ªã cho b·ªô l·ªçc m·ªõi
                market: [], // M·∫£ng ƒë·ªÉ l∆∞u tr·ªØ c√°c th·ªã tr∆∞·ªùng ƒë∆∞·ª£c ch·ªçn
                product: [] // M·∫£ng ƒë·ªÉ l∆∞u tr·ªØ c√°c s·∫£n ph·∫©m ƒë∆∞·ª£c ch·ªçn
            },
            mgtNoiBoOrder: [],
            isMgtNoiBoOrderLoading: false,
            currentPage: 1,
            rowsPerPage: 70,
            totalFilteredOrders: 0
        };
        let pasteAnchorCell = null;
        let isUpdatingSingleCell = false;
        let isPasting = false;

        const btnToggleOrderErrorView = document.getElementById("toggleOrderErrorView");
        const popup = document.getElementById("popup");
        const closeBtnToggleOrderErrorView = document.getElementById("closePopup");
        const popupTableContainer = document.getElementById("popupTableContainer");

        // TH√äM M·ªöI: L·∫•y c√°c n√∫t trong popup
        const clearErrorOrdersBtn = document.getElementById("clearErrorOrdersBtn");
        const updateErrorOrdersBtn = document.getElementById("updateErrorOrdersBtn");

        clearErrorOrdersBtn.addEventListener("click", ()=>{
            localStorage.removeItem('orderErrorView')
            location.reload();

        });
        updateErrorOrdersBtn.addEventListener("click", () => {
            var errorOrders = JSON.parse(localStorage.getItem('orderErrorView'));
            if (!errorOrders || Object.keys(errorOrders).length === 0) {
                showCustomAlert('Kh√¥ng c√≥ ƒë∆°n h√†ng l·ªói n√†o ƒë·ªÉ c·∫≠p nh·∫≠t.', 'info');
                return;
            }

            const changesToApply = new Map(); // D√πng ƒë·ªÉ l∆∞u tr·ªØ c√°c thay ƒë·ªïi c·∫ßn √°p d·ª•ng
            let actualUpdatesCount = 0;

            for (const orderId in errorOrders) {
                const fields = errorOrders[orderId];
                const originalRowData = state.allData.find(data => data[PRIMARY_KEY_COLUMN] === orderId);

                if (!originalRowData) {
                    console.warn(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi M√£ ƒë∆°n h√†ng: ${orderId} trong d·ªØ li·ªáu hi·ªán t·∫°i. B·ªè qua.`);
                    continue;
                }

                // L∆∞u c√°c thay ƒë·ªïi h·ª£p l·ªá v√†o changesToApply
                for (const field in fields) {
                    const { newValue, originalValue } = fields[field];

                    // Ki·ªÉm tra n·∫øu gi√° tr·ªã hi·ªán t·∫°i trong state.allData kh·ªõp v·ªõi originalValue
                    // v√† kh√°c v·ªõi newValue ƒë·ªÉ tr√°nh c·∫≠p nh·∫≠t l·∫°i nh·ªØng gi√° tr·ªã ƒë√£ ƒë√∫ng
                    if (originalRowData[field] === originalValue && originalValue !== newValue) {
                        if (!changesToApply.has(orderId)) {
                            changesToApply.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId });
                        }
                        changesToApply.get(orderId)[field] = newValue;
                        actualUpdatesCount++;
                    }
                }
            }

            if (changesToApply.size > 0) {
                // Chuy·ªÉn Map th√†nh m·∫£ng ƒë·ªÉ g·ª≠i ƒëi
                const rowsToSend = Array.from(changesToApply.values());
                batchUpdatePastedData(rowsToSend); // S·ª≠ d·ª•ng h√†m batchUpdatePastedData c√≥ s·∫µn ƒë·ªÉ x·ª≠ l√Ω g·ª≠i API
                // H√†m batchUpdatePastedData s·∫Ω lo vi·ªác c·∫≠p nh·∫≠t state.allData, state.pendingChanges, legacyChanges v√† render
                showCustomAlert(`ƒêang g·ª≠i l·∫°i ${actualUpdatesCount} thay ƒë·ªïi cho ${changesToApply.size} ƒë∆°n h√†ng l·ªói...`, 'info', 4000);
            } else {
                showCustomAlert('Kh√¥ng c√≥ thay ƒë·ªïi h·ª£p l·ªá n√†o ƒë·ªÉ c·∫≠p nh·∫≠t l·∫°i.', 'info');
            }
            popup.style.display = "none"; // ·∫®n popup sau khi x·ª≠ l√Ω
        });

        // Khi click n√∫t => hi·ªÉn th·ªã popup
        btnToggleOrderErrorView.addEventListener("click", () => {
            popup.style.display = "block";
            renderErrorTable();
        });

        function renderErrorTable() {
            var data = JSON.parse(localStorage.getItem('orderErrorView'))

            popupTableContainer.innerHTML = ''; // X√≥a n·ªôi dung c≈© m·ªói khi render
            let isValue = false;

            let tableHtml = ``;
            tableHtml += `<table class="popover-table">`;
            tableHtml += `
            <thead>
                <tr>
                    <th>M√£ ƒê∆°n H√†ng</th>
                    <th>C·ªôt Thay ƒê·ªïi</th>
                    <th>Gi√° Tr·ªã</th>
                </tr>
            </thead>
            `;
            tableHtml += '<tbody>';

            for (const orderId in data) {
                const fields = data[orderId]; // v√≠ d·ª•: { "M√£ Tracking": {newValue, originalValue} }
                // duy·ªát t·ª´ng field trong orderId
                for (const field in fields) {
                    const { newValue, originalValue } = fields[field];
                    isValue = true;

                    tableHtml += `
                        <tr>
                            <td>${orderId}</td>
                            <td>${field}</td>
                            <td>
                                <span class="old-value">${originalValue}</span>
                                <span class="new-value">${newValue}</span>
                            </td>
                        </tr>
                    `;
                }
            }

            tableHtml += `
                </tbody>
            </table>`;

            if(isValue){
                popupTableContainer.innerHTML = tableHtml;
            }
        }

        // Khi click d·∫•u X => ·∫©n popup
        closeBtnToggleOrderErrorView.addEventListener("click", () => {
            popup.style.display = "none";
        });

        // Khi click ra ngo√†i khung => ·∫©n popup
        window.addEventListener("click", (e) => {
            if (e.target === popup) {
                popup.style.display = "none";
            }
        });

        // --- H√ÄM TH√îNG B√ÅO TOAST ---
        function showCustomAlert(message, type = 'info', duration = 3000) { const container = document.getElementById('toastContainer'); const toast = document.createElement('div'); toast.className = `toast ${type}`; const messageSpan = document.createElement('span'); messageSpan.textContent = message; const closeBtn = document.createElement('button'); closeBtn.className = 'toast-close'; closeBtn.innerHTML = '√ó'; closeBtn.onclick = () => removeToast(toast); toast.appendChild(messageSpan); toast.appendChild(closeBtn); container.appendChild(toast); setTimeout(() => { toast.classList.add('show'); }, 10); if (duration > 0) { setTimeout(() => { removeToast(toast); }, duration); } return toast; }
        function removeToast(toast) { if (!toast || !toast.parentNode) return; toast.classList.remove('show'); setTimeout(() => { if (toast.parentNode) { toast.parentNode.removeChild(toast); } }, 300); }
        function clearAllToasts() { const container = document.getElementById('toastContainer'); const toasts = container.querySelectorAll('.toast'); toasts.forEach(toast => removeToast(toast)); }

        // --- C√ÅC H√ÄM UTILITY ---
        function formatDate(dateString) { if (!dateString) return ''; try { const date = new Date(dateString.includes('Z') ? dateString : dateString + 'Z'); if (isNaN(date.getTime())) return dateString; const day = String(date.getDate()).padStart(2, '0'); const month = String(date.getMonth() + 1).padStart(2, '0'); const year = date.getFullYear(); return `${day}/${month}/${year}`; } catch (e) { return dateString; } }
        function parseDateToISO(dateString) { if (!dateString || dateString.length === 0) return ''; const parts = dateString.split('/'); if (parts.length === 3) { const day = parseInt(parts[0], 10); const month = parseInt(parts[1], 10) - 1; const year = parseInt(parts[2], 10); const date = new Date(year, month, day); if (!isNaN(date.getTime())) { return date.toISOString().split('T')[0]; } } return dateString; }
        function updateOrderCounter(count) { const counterElement = document.getElementById('orderCounter'); if (counterElement) { counterElement.innerHTML = `T·ªïng s·ªë ƒë∆°n: <b>${count}</b>`; } }

        // --- LOCAL STORAGE HANDLING ---
        function savePendingChangesToLocalStorage() {
            const serializableChanges = {};
            // S·ª¨A ƒê·ªîI: G·ªôp c·∫£ 2 lo·∫°i thay ƒë·ªïi v√†o localStorage
            const allChanges = new Map([...state.legacyChanges, ...state.pendingChanges]);
            allChanges.forEach((colChanges, orderId) => {
                serializableChanges[orderId] = {};
                colChanges.forEach((changeInfo, colName) => {
                    serializableChanges[orderId][colName] = {
                        newValue: changeInfo.newValue,
                        originalValue: changeInfo.originalValue,
                    };
                });
            });
            
            localStorage.setItem('speegoPendingChanges', JSON.stringify(serializableChanges));
            if (Object.keys(serializableChanges).length !== 0) {
                let oldData = localStorage.getItem('orderErrorView');
                oldData = oldData ? JSON.parse(oldData) : {};

                for (const orderId in serializableChanges) {
                    if (serializableChanges.hasOwnProperty(orderId)) {
                        if (!oldData[orderId]) {
                            // N·∫øu orderId ch∆∞a t·ªìn t·∫°i trong oldData, th√™m m·ªõi ho√†n to√†n
                            oldData[orderId] = serializableChanges[orderId];
                        } else {
                            // N·∫øu orderId ƒë√£ t·ªìn t·∫°i, g·ªôp c√°c field b√™n trong
                            // C√°c field tr√πng l·∫∑p trong serializableChanges s·∫Ω ghi ƒë√® l√™n oldData
                            Object.assign(oldData[orderId], serializableChanges[orderId]);
                        }
                    }
                }
                // L∆∞u l·∫°i d·ªØ li·ªáu ƒë√£ g·ªôp
                localStorage.setItem('orderErrorView', JSON.stringify(oldData));
            }
            updateSyncButtonBadge(); // M·ªöI: C·∫≠p nh·∫≠t badge m·ªói khi l∆∞u
        }

        function loadPendingChangesFromLocalStorage() {
            const storedChanges = localStorage.getItem('speegoPendingChanges');
            if (storedChanges) {
                try {
                    const parsedChanges = JSON.parse(storedChanges);
                    // S·ª¨A ƒê·ªîI: Ch·ªâ load v√†o legacyChanges, kh√¥ng ƒë·ªông ƒë·∫øn pendingChanges
                    state.legacyChanges.clear();
                    for (const orderId in parsedChanges) {
                        const colChangesMap = new Map();
                        for (const colName in parsedChanges[orderId]) {
                            colChangesMap.set(colName, {
                                newValue: parsedChanges[orderId][colName].newValue,
                                originalValue: parsedChanges[orderId][colName].originalValue,
                                cellElement: null
                            });
                        }
                        state.legacyChanges.set(orderId, colChangesMap);
                    }
                    updateSyncButtonBadge(); // M·ªöI: C·∫≠p nh·∫≠t badge sau khi load
                } catch (e) {
                    console.error("L·ªói khi ƒë·ªçc l·ªãch s·ª≠ thay ƒë·ªïi t·ª´ localStorage:", e);
                    localStorage.removeItem('speegoPendingChanges');
                }
            }
        }

        function removeOrderErrorViewWhere(){
            var data = JSON.parse(localStorage.getItem('orderErrorView'));
            if (!data) return; // Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ x·ª≠ l√Ω

            let changesMade = false; // C·ªù ƒë·ªÉ ki·ªÉm tra xem c√≥ thay ƒë·ªïi n√†o ƒë∆∞·ª£c th·ª±c hi·ªán kh√¥ng

            for (const orderId in data) {
                if (data.hasOwnProperty(orderId)) { // ƒê·∫£m b·∫£o ch·ªâ duy·ªát qua c√°c thu·ªôc t√≠nh ri√™ng c·ªßa ƒë·ªëi t∆∞·ª£ng
                    const fields = data[orderId];
                    // T·∫°o m·ªôt b·∫£n sao c·ªßa fields ƒë·ªÉ tr√°nh l·ªói khi x√≥a ph·∫ßn t·ª≠ trong l√∫c l·∫∑p
                    const fieldsToDelete = [];
                    for (const field in fields) {
                        if (fields.hasOwnProperty(field)) {
                            const { newValue } = fields[field];
                            
                            // T√¨m d·ªØ li·ªáu g·ªëc trong state.allData
                            const originalRowData = state.allData.find(d => d[PRIMARY_KEY_COLUMN] === orderId);

                            if (originalRowData && originalRowData[field] === newValue) {
                                // N·∫øu gi√° tr·ªã hi·ªán t·∫°i trong state.allData kh·ªõp v·ªõi newValue c·ªßa l·ªói,
                                // c√≥ nghƒ©a l√† l·ªói ƒë√£ ƒë∆∞·ª£c s·ª≠a ho·∫∑c gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng.
                                // ƒê√°nh d·∫•u tr∆∞·ªùng n√†y ƒë·ªÉ x√≥a.
                                fieldsToDelete.push(field);
                                changesMade = true;
                            }
                        }
                    }

                    // Th·ª±c hi·ªán x√≥a c√°c tr∆∞·ªùng ƒë√£ ƒë√°nh d·∫•u
                    fieldsToDelete.forEach(field => {
                        delete data[orderId][field];
                    });

                    // N·∫øu sau khi x√≥a, kh√¥ng c√≤n tr∆∞·ªùng n√†o trong orderId n√†y, x√≥a c·∫£ orderId
                    if (Object.keys(data[orderId]).length === 0) {
                        delete data[orderId];
                        changesMade = true;
                    }
                }
            }

            // N·∫øu c√≥ b·∫•t k·ª≥ thay ƒë·ªïi n√†o, l∆∞u l·∫°i v√†o localStorage
            if (changesMade) {
                localStorage.setItem('orderErrorView', JSON.stringify(data));
                console.log("ƒê√£ c·∫≠p nh·∫≠t localStorage 'orderErrorView' sau khi x√≥a c√°c l·ªói ƒë√£ ƒë∆∞·ª£c s·ª≠a.");
            }
        }

        // --- X·ª¨ L√ù D·ªÆ LI·ªÜU V√Ä L·ªåC ---
        function handleData(response) {
            document.getElementById('refreshData').disabled = false;
            document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu';
            state.allData = [];
            if (response.error) { showCustomAlert(`L·ªói t·∫£i d·ªØ li·ªáu: ${response.error}`, 'error'); return; }
            const data = response.rows || response.data || response;
            if (!Array.isArray(data)) { showCustomAlert('D·ªØ li·ªáu tr·∫£ v·ªÅ kh√¥ng h·ª£p l·ªá.', 'error'); return; }
            state.allData = data;
            
            removeOrderErrorViewWhere()

            // S·ª¨A ƒê·ªîI: Kh√¥ng t·ª± ƒë·ªông √°p d·ª•ng thay ƒë·ªïi t·ª´ localStorage v√†o b·∫£ng n·ªØa.
            // Ch·ªâ c·∫ßn load v√† hi·ªÉn th·ªã badge.
            loadPendingChangesFromLocalStorage();

            const initialDataForFilters = filterByCarrier(state.allData);
            populateMainFilters(initialDataForFilters);
            createTabs(initialDataForFilters);
            setupColumnFilters();
            if (state.activeTeam === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) {
                fetchMGTNoiBoOrder().then(render);
            } else {
                render();
            }
        }

        function filterByCarrier(data) { /* ... Gi·ªØ nguy√™n ... */ return data.filter(row => { const carrier = row["ƒê∆°n v·ªã v·∫≠n chuy·ªÉn"] || row["ƒê∆°n_v·ªã_v·∫≠n_chuy·ªÉn"]; return carrier?.toString().toUpperCase() === "MGT"; }); }
        async function fetchMGTNoiBoOrder() { /* ... Gi·ªØ nguy√™n ... */ if (state.isMgtNoiBoOrderLoading) return; state.isMgtNoiBoOrderLoading = true; const loadingToast = showCustomAlert('ƒêang t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô...', 'info', 0); try { const response = await fetch(MGT_NOI_BO_ORDER_API_URL); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const json = await response.json(); if (json.data && Array.isArray(json.data)) { state.mgtNoiBoOrder = json.data.map(row => row[PRIMARY_KEY_COLUMN]).filter(Boolean); removeToast(loadingToast); showCustomAlert('ƒê√£ t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô.', 'success', 2000); } else { state.mgtNoiBoOrder = []; removeToast(loadingToast); showCustomAlert('Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.', 'error'); } } catch (e) { console.error('L·ªói khi t·∫£i d·ªØ li·ªáu MGT N·ªôi B·ªô:', e); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi khi t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô: ${e.message}`, 'error'); state.mgtNoiBoOrder = []; } finally { state.isMgtNoiBoOrderLoading = false; } }

        // --- C·∫¨P NH·∫¨T: H√†m t·∫°o b·ªô l·ªçc ch√≠nh th√†nh multi-select ---
        function populateMainFilters(data) {
            const markets = [...new Set(data.map(row => row["Khu v·ª±c"]).filter(Boolean))].sort();
            const products = [...new Set(data.map(row => row["M·∫∑t h√†ng"]).filter(Boolean))].sort();

            const createMainMultiSelect = (
                options,
                displayId,
                dropdownId,
                stateKey,
                placeholder
            ) => {
                const display = document.getElementById(displayId);
                const dropdown = document.getElementById(dropdownId);
                dropdown.innerHTML = '';

                let selectedValues = state.filterValues[stateKey] || [];

                const updateDisplay = () => {
                    if (selectedValues.length === 0 || selectedValues.length === options.length) {
                        display.textContent = placeholder;
                    } else if (selectedValues.length === 1) {
                        display.textContent = selectedValues[0];
                    } else {
                        display.textContent = `${selectedValues.length} ƒë√£ ch·ªçn`;
                    }
                };

                // Add "T·∫•t c·∫£" option
                const allItem = document.createElement('div');
                allItem.className = 'multiselect-item';
                allItem.innerHTML = `<input type="checkbox" id="filter-${stateKey}-all"><label for="filter-${stateKey}-all"><b>T·∫•t c·∫£</b></label>`;
                dropdown.appendChild(allItem);


                options.forEach(option => {
                    const item = document.createElement('div');
                    item.className = 'multiselect-item';
                    const isChecked = selectedValues.includes(option);
                    item.innerHTML = `<input type="checkbox" id="filter-${stateKey}-${option}" value="${option}" ${isChecked ? 'checked' : ''}><label for="filter-${stateKey}-${option}">${option}</label>`;
                    dropdown.appendChild(item);
                });

                const allCheckbox = dropdown.querySelector(`#filter-${stateKey}-all`);
                const optionCheckboxes = dropdown.querySelectorAll(`input[type="checkbox"]:not(#filter-${stateKey}-all)`);

                const syncAllCheckboxState = () => {
                    const allOptionsSelected = selectedValues.length === options.length;
                    allCheckbox.checked = allOptionsSelected;
                };

                dropdown.addEventListener('change', (e) => {
                    const target = e.target;

                    if (target.id === `filter-${stateKey}-all`) {
                        optionCheckboxes.forEach(cb => cb.checked = target.checked);
                        selectedValues = target.checked ? [...options] : [];
                    } else {
                        const value = target.value;
                        if (target.checked) {
                            if (!selectedValues.includes(value)) selectedValues.push(value);
                        } else {
                            selectedValues = selectedValues.filter(v => v !== value);
                        }
                    }

                    state.filterValues[stateKey] = selectedValues;
                    syncAllCheckboxState();
                    updateDisplay();
                    state.currentPage = 1;
                    render();
                });

                display.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // ƒê√≥ng c√°c dropdown kh√°c tr∆∞·ªõc khi m·ªü dropdown n√†y
                    document.querySelectorAll('.multiselect-dropdown.show').forEach(d => {
                        if (d.id !== dropdownId) d.classList.remove('show');
                    });
                    dropdown.classList.toggle('show');
                });

                syncAllCheckboxState();
                updateDisplay();
            };

            createMainMultiSelect(markets, 'filterMarketDisplay', 'filterMarketDropdown', 'market', 'T·∫•t c·∫£ Th·ªã tr∆∞·ªùng');
            createMainMultiSelect(products, 'filterProductDisplay', 'filterProductDropdown', 'product', 'T·∫•t c·∫£ S·∫£n ph·∫©m');
        }


        function getFilteredData() {
            const dataToFilter = [...state.allData];
            const mgtData = filterByCarrier(dataToFilter);

            let dataToRender = mgtData;

            // --- C·∫¨P NH·∫¨T: √Åp d·ª•ng b·ªô l·ªçc multi-select v√† c√°c b·ªô l·ªçc kh√°c ---
            const markets = state.filterValues.market || [];
            const products = state.filterValues.product || [];
            const dateFrom = document.getElementById('filterDateFrom').value;
            const dateTo = document.getElementById('filterDateTo').value;

            if (markets.length > 0) {
                const marketSet = new Set(markets);
                dataToRender = dataToRender.filter(row => marketSet.has(row["Khu v·ª±c"]));
            }
            if (products.length > 0) {
                const productSet = new Set(products);
                dataToRender = dataToRender.filter(row => productSet.has(row["M·∫∑t h√†ng"]));
            }
            if (dateFrom) { const from = new Date(dateFrom); from.setHours(0, 0, 0, 0); dataToRender = dataToRender.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) >= from); }
            if (dateTo) { const to = new Date(dateTo); to.setHours(23, 59, 59, 999); dataToRender = dataToRender.filter(row => row["Ng√†y l√™n ƒë∆°n"] && new Date(row["Ng√†y l√™n ƒë∆°n"]) <= to); }
            if (state.activeTeam === 'mgt_noi_bo') { if (state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) { state.totalFilteredOrders = 0; return []; } const orderedIds = new Set(state.mgtNoiBoOrder); dataToRender = dataToRender.filter(row => orderedIds.has(row["M√£ ƒë∆°n h√†ng"])); const orderIndexMap = new Map(state.mgtNoiBoOrder.map((id, index) => [id, index])); dataToRender.sort((a, b) => { const indexA = orderIndexMap.get(a[PRIMARY_KEY_COLUMN]); const indexB = orderIndexMap.get(b[PRIMARY_KEY_COLUMN]); return indexA - indexB; }); } else if (state.activeTeam !== 'all') { dataToRender = dataToRender.filter(row => row[TEAM_COLUMN_NAME] === state.activeTeam); }

            const trackingIncludeRaw = state.filterValues['tracking_include'] || '';
            const trackingExcludeRaw = state.filterValues['tracking_exclude'] || '';

            // --- S·ª¨A ƒê·ªîI PH·∫¶N L·ªåC C·ªòT ---
            const otherColumnFilters = Object.entries(state.filterValues)
                .filter(([key, val]) => !['market', 'product'].includes(key) && !key.startsWith('tracking_') && ((Array.isArray(val) && val.length > 0) || (typeof val === 'string' && val.trim() !== '')));

            if (otherColumnFilters.length > 0) {
                dataToRender = dataToRender.filter(row => {
                    return otherColumnFilters.every(([col, filterValue]) => {
                        const dataKey = columnMapping[col] || col;
                        const cellValue = (row[dataKey] ?? row[col] ?? row[dataKey.replace(/ /g, '_')] ?? '').toString().trim();

                        if (dataKey === "Tr·∫°ng th√°i giao h√†ng") { // Logic l·ªçc ƒë·∫∑c bi·ªát cho c·ªôt n√†y
                            const EMPTY_OPTION_VALUE = '__EMPTY__';
                            const selectedStatuses = filterValue; // ƒê√¢y l√† m·ªôt m·∫£ng

                            if (selectedStatuses.length === 0) return true; // N·∫øu m·∫£ng r·ªóng th√¨ kh√¥ng l·ªçc

                            const hasEmptyFilter = selectedStatuses.includes(EMPTY_OPTION_VALUE);

                            // N·∫øu √¥ tr·ªëng v√† ng∆∞·ªùi d√πng ch·ªçn "(Tr·ªëng)"
                            if (cellValue === '' && hasEmptyFilter) {
                                return true;
                            }

                            // N·∫øu gi√° tr·ªã c·ªßa √¥ c√≥ trong danh s√°ch ƒë∆∞·ª£c ch·ªçn
                            if (selectedStatuses.includes(cellValue)) {
                                return true;
                            }

                            return false; // Kh√¥ng kh·ªõp ƒëi·ªÅu ki·ªán n√†o
                        } else if (["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) {
                            const dateValue = new Date(cellValue);
                            const filterDate = new Date(filterValue);
                            return dateValue >= filterDate;
                        } else { // Logic l·ªçc c≈© cho c√°c c·ªôt kh√°c
                            return cellValue.toLowerCase().includes(filterValue.toLowerCase());
                        }
                    });
                });
            }
            // --- K·∫æT TH√öC S·ª¨A ƒê·ªîI ---

            if (trackingIncludeRaw || trackingExcludeRaw) { const lowerInclude = trackingIncludeRaw.toLowerCase(); const lowerExclude = trackingExcludeRaw.toLowerCase(); dataToRender = dataToRender.filter(row => { const cellValue = String(row['M√£ Tracking'] || ''); const lowerCellValue = cellValue.toLowerCase(); if (lowerExclude && lowerCellValue.includes(lowerExclude)) { return false; } if (lowerInclude) { if (lowerInclude.includes('\n')) { const codes = new Set(trackingIncludeRaw.split('\n').map(t => t.trim()).filter(Boolean)); if (!codes.has(cellValue.trim())) return false; } else { if (!lowerCellValue.includes(lowerInclude)) return false; } } return true; }); }

            // <-- LOGIC M·ªöI: X·ª≠ l√Ω c√°c ch·∫ø ƒë·ªô xem tracking -->
            if (state.showDuplicateTrackingOrders) {
                const trackingCounts = new Map();
                dataToRender.forEach(row => {
                    const trackingCode = String(row["M√£ Tracking"] || '').trim();
                    if (trackingCode) {
                        trackingCounts.set(trackingCode, (trackingCounts.get(trackingCode) || 0) + 1);
                    }
                });
                const duplicateTrackings = new Set();
                for (const [code, count] of trackingCounts.entries()) {
                    if (count > 1) {
                        duplicateTrackings.add(code);
                    }
                }
                dataToRender = dataToRender.filter(row => {
                    const trackingCode = String(row["M√£ Tracking"] || '').trim();
                    return duplicateTrackings.has(trackingCode);
                });
                
                // S·∫Øp x·∫øp ƒë·ªÉ c√°c ƒë∆°n c√πng m√£ tracking n·∫±m c·∫°nh nhau
                dataToRender.sort((a, b) => {
                    const trackingA = String(a["M√£ Tracking"] || '').trim();
                    const trackingB = String(b["M√£ Tracking"] || '').trim();
                    
                    // S·∫Øp x·∫øp theo m√£ tracking tr∆∞·ªõc
                    const trackingComparison = trackingA.localeCompare(trackingB);
                    if (trackingComparison !== 0) {
                        return trackingComparison;
                    }
                    
                    // N·∫øu c√πng m√£ tracking, s·∫Øp x·∫øp theo m√£ ƒë∆°n h√†ng
                    const orderIdA = a[PRIMARY_KEY_COLUMN] || '';
                    const orderIdB = b[PRIMARY_KEY_COLUMN] || '';
                    return orderIdA.localeCompare(orderIdB);
                });
            } else { // Ch·ªâ √°p d·ª•ng b·ªô l·ªçc c√≥/kh√¥ng c√≥ tracking khi kh√¥ng ·ªü ch·∫ø ƒë·ªô xem tr√πng
                dataToRender = dataToRender.filter(row => {
                    const trackingCode = String(row["M√£ Tracking"] || row["M√£_Tracking"] || '');
                    return state.showTrackingOrders ? trackingCode.trim() !== '' : !trackingCode.trim();
                });
            }
            // <-- K·∫æT TH√öC LOGIC M·ªöI -->

            // Ch·ªâ s·∫Øp x·∫øp theo ng√†y k·∫ø to√°n khi kh√¥ng ·ªü ch·∫ø ƒë·ªô xem ƒë∆°n tr√πng
            if (state.activeTeam !== 'mgt_noi_bo' && !state.showDuplicateTrackingOrders) { const primarySortKey = 'Ng√†y K·∫ø to√°n ƒë·ªëi so√°t v·ªõi FFM l·∫ßn 2'; const secondarySortKey = PRIMARY_KEY_COLUMN; dataToRender.sort((a, b) => { const parseDate = (val) => { if (!val) return null; const date = new Date(val); return isNaN(date.getTime()) ? null : date; }; const dateA = parseDate(a[primarySortKey]); const dateB = parseDate(b[primarySortKey]); if (dateA === null && dateB === null) { } else if (dateA === null) { return 1; } else if (dateB === null) { return -1; } else { const dateComparison = dateA.getTime() - dateB.getTime(); if (dateComparison !== 0) { return dateComparison; } } const orderIdA = a[secondarySortKey] || ''; const orderIdB = b[secondarySortKey] || ''; return orderIdA.localeCompare(orderIdB); }); }

            state.totalFilteredOrders = dataToRender.length;
            const startIndex = (state.currentPage - 1) * state.rowsPerPage;
            const endIndex = startIndex + state.rowsPerPage;
            return dataToRender.slice(startIndex, endIndex);
        }

        // --- H√ÄM C·ªê ƒê·ªäNH C·ªòT ƒê·ªòNG ---
        function updateFixedColumns() { /* ... Gi·ªØ nguy√™n ... */ const numFixed = parseInt(document.getElementById('fixedColumns').value, 10); const table = document.querySelector('.table-wrapper table'); if (!table) return; const rows = Array.from(table.rows); rows.forEach(row => { Array.from(row.cells).forEach(cell => { cell.classList.remove('fixed-column'); cell.style.left = ''; }); }); if (numFixed <= 0 || rows.length < 2) return; const headerCells = rows[1].cells; const offsets = [0]; for (let i = 1; i < numFixed; i++) { if (headerCells[i - 1]) { offsets[i] = offsets[i - 1] + headerCells[i - 1].offsetWidth; } } rows.forEach(row => { for (let i = 0; i < numFixed; i++) { const cell = row.cells[i]; if (cell) { cell.classList.add('fixed-column'); cell.style.left = `${offsets[i] || 0}px`; } } }); }

        // --- RENDER GIAO DI·ªÜN ---
        function render() {
            const paginatedData = getFilteredData();
            const container = document.getElementById('tableBody');
            container.innerHTML = '';
            if (paginatedData.length === 0) { /* ... Gi·ªØ nguy√™n ... */ let message = 'Kh√¥ng c√≥ d·ªØ li·ªáu ph√π h·ª£p'; if (state.activeTeam === 'mgt_noi_bo' && state.isMgtNoiBoOrderLoading) { message = 'ƒêang t·∫£i danh s√°ch ƒë∆°n h√†ng n·ªôi b·ªô...'; } container.innerHTML = `<tr><td colspan="${displayColumns.length}" class="no-data">${message}</td></tr>`; updateOrderCounter(state.totalFilteredOrders); updatePaginationControls(); return; }
            updateOrderCounter(state.totalFilteredOrders);

            paginatedData.forEach((row) => {
                const tr = document.createElement('tr');
                const orderId = row[PRIMARY_KEY_COLUMN];
                tr.dataset.orderId = orderId;

                displayColumns.forEach(col => {
                    const td = document.createElement('td');
                    const dataKey = columnMapping[col] || col;
                    const originalValue = String(row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? '');

                    // S·ª¨A ƒê·ªîI: Ki·ªÉm tra xem c√≥ gi√° tr·ªã m·ªõi trong pendingChanges ho·∫∑c legacyChanges kh√¥ng
                    const pendingChange = state.pendingChanges.get(orderId)?.get(dataKey) || state.legacyChanges.get(orderId)?.get(dataKey);
                    let displayValue = pendingChange ? pendingChange.newValue : originalValue;

                    if (["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) {
                        displayValue = formatDate(displayValue);
                    }

                    if (col === "Ghi ch√∫ v·∫≠n ƒë∆°n" && displayValue) { td.classList.add('note-highlight'); }
                    const checkValue = String(displayValue).trim().toLowerCase();
                    td.classList.remove('status-ok', 'status-cancel');
                    if (col === "K·∫øt qu·∫£ check") { if (checkValue === 'ok') td.classList.add('status-ok'); else if (checkValue.includes('hu·ª∑')) td.classList.add('status-cancel'); }

                    if (editableCols.includes(col)) {
                        td.classList.add('editable');
                        if (pendingChange) {
                            td.classList.add('highlight');
                            pendingChange.cellElement = td;
                        } else {
                            td.classList.remove('highlight');
                        }

                        // S·ª¨A ƒê·ªîI: To√†n b·ªô logic `handleCellChange` ƒë√£ ƒë∆∞·ª£c c·∫£i ti·∫øn
                        const handleCellChange = (newValue, element) => {

                            if (isUpdatingSingleCell) return;

                            let finalValueForState = newValue;
                            if (col === "Ng√†y ƒë√≥ng h√†ng" && newValue) {
                                // Gi√° tr·ªã t·ª´ input type date l√† 'YYYY-MM-DD', chuy·ªÉn ƒë·ªïi n·∫øu c·∫ßn
                                finalValueForState = new Date(newValue).toLocaleDateString('en-US');
                            } else {
                                finalValueForState = String(newValue);
                            }

                            // S·ª¨A ƒê·ªîI C·ªêT L√ïI: Lu√¥n t√¨m v√† so s√°nh v·ªõi d·ªØ li·ªáu g·ªëc t·ª´ state.allData
                            const originalRowData = state.allData.find(r => r[PRIMARY_KEY_COLUMN] === orderId);
                            const trueOriginalValue = originalRowData ? String(originalRowData[dataKey] ?? '') : '';

                            const isChanged = finalValueForState !== trueOriginalValue;

                            if (isChanged) {
                                if (!state.pendingChanges.has(orderId)) {
                                    state.pendingChanges.set(orderId, new Map());
                                }
                                const changeInfo = {
                                    newValue: finalValueForState,
                                    originalValue: trueOriginalValue,
                                    cellElement: td
                                };
                                state.pendingChanges.get(orderId).set(dataKey, changeInfo);
                                td.classList.add('highlight');
                                savePendingChangesToLocalStorage();

                                // THAY ƒê·ªîI: Ki·ªÉm tra n·∫øu l√† c·ªôt "M√£ Tracking" th√¨ kh√¥ng t·ª± ƒë·ªông c·∫≠p nh·∫≠t
                                const isTrackingColumn = col === "M√£ Tracking" || dataKey === "M√£ Tracking";
                                if (!isPasting && !isTrackingColumn) {
                                    handleSingleCellUpdate(orderId, dataKey, finalValueForState, td);
                                } else if (isTrackingColumn) {
                                    showCustomAlert('Thay ƒë·ªïi M√£ Tracking ƒë√£ ƒë∆∞·ª£c l∆∞u. Vui l√≤ng b·∫•m "C·∫≠p nh·∫≠t t·∫•t c·∫£" ƒë·ªÉ g·ª≠i d·ªØ li·ªáu.', 'info', 4000);
                                }
                            } else {
                                // N·∫øu gi√° tr·ªã quay v·ªÅ g·ªëc, x√≥a kh·ªèi pending changes
                                const orderChanges = state.pendingChanges.get(orderId);
                                if (orderChanges) {
                                    orderChanges.delete(dataKey);
                                    if (orderChanges.size === 0) state.pendingChanges.delete(orderId);
                                }
                                // C≈©ng c√≥ th·ªÉ n√≥ n·∫±m trong legacy, c·∫ßn x√≥a c·∫£ ·ªü ƒë√≥
                                const legacyOrderChanges = state.legacyChanges.get(orderId);
                                if (legacyOrderChanges) {
                                    legacyOrderChanges.delete(dataKey);
                                    if (legacyOrderChanges.size === 0) state.legacyChanges.delete(orderId);
                                }
                                td.classList.remove('highlight');
                                savePendingChangesToLocalStorage();
                            }

                            updateSelectionSummary();
                        };

                        // ... ph·∫ßn render select/input gi·ªØ nguy√™n ...
                        if (col === "K·∫øt qu·∫£ check") {
                            td.classList.add('editable-dropdown-cell');
                            const select = document.createElement('select');
                            select.className = 'editable-select';
                            const currentVal = String(displayValue);
                            const optionsToAdd = new Set(checkStatusOptions);
                            if (currentVal && !optionsToAdd.has(currentVal)) {
                                optionsToAdd.add(currentVal);
                            }
                            Array.from(optionsToAdd).sort().forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt; option.textContent = opt;
                                if (opt.toLowerCase() === currentVal.toLowerCase()) { option.selected = true; }
                                select.appendChild(option);
                            });
                            select.addEventListener('change', () => {
                                handleCellChange(select.value, select);
                                const selectedVal = select.value.toLowerCase();
                                td.classList.remove('status-ok', 'status-cancel');
                                if (selectedVal === 'ok') td.classList.add('status-ok');
                                else if (selectedVal.includes('hu·ª∑')) td.classList.add('status-cancel');
                            });
                            td.innerHTML = '';
                            td.appendChild(select);
                        } else if (col === "Ng√†y ƒë√≥ng h√†ng") {
                            const input = document.createElement('input');
                            input.type = 'date';
                            input.className = 'date-input';
                            // Gi√° tr·ªã cho input date ph·∫£i l√† YYYY-MM-DD
                            try {
                                if (displayValue) {
                                    const dateParts = displayValue.split('/');
                                    if (dateParts.length === 3) {
                                        input.value = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
                                    } else if (new Date(displayValue) != "Invalid Date") {
                                        input.value = new Date(displayValue).toISOString().split('T')[0];
                                    }
                                }
                            } catch (e) { /* ignore invalid date */ }
                            td.style.padding = '0';
                            input.style.padding = '8px 12px';
                            input.addEventListener('change', () => handleCellChange(input.value, input));
                            input.addEventListener('blur', () => handleCellChange(input.value, input));
                            td.innerHTML = '';
                            td.appendChild(input);
                        } else {
                            td.contentEditable = 'true';
                            td.textContent = displayValue;
                            td.addEventListener('blur', () => handleCellChange(td.textContent, td));
                        }
                    } else {
                        td.textContent = displayValue;
                    }
                    tr.appendChild(td);
                });
                container.appendChild(tr);
            });
            updateFixedColumns();
            updatePaginationControls();
        }

        // --- C·∫≠p nh·∫≠t v√† ph√¢n trang ---
        function updatePaginationControls() { /* ... Gi·ªØ nguy√™n ... */ const prevBtn = document.getElementById('prevPage'); const nextPage = document.getElementById('nextPage'); const pageInfo = document.getElementById('pageInfo'); const rowsPerPageSelect = document.getElementById('rowsPerPageSelect'); const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage); pageInfo.textContent = `Trang ${state.currentPage}/${totalPages || 1}`; prevBtn.disabled = state.currentPage <= 1; nextPage.disabled = state.currentPage >= totalPages; rowsPerPageSelect.value = state.rowsPerPage; }
        async function handleSingleCellUpdate(orderId, columnKey, newValue, cellElement) { /* ... Gi·ªØ nguy√™n ... */ if (isUpdatingSingleCell) return; isUpdatingSingleCell = true; document.getElementById('updateAll').disabled = true; const loadingToast = showCustomAlert('ƒêang c·∫≠p nh·∫≠t...', 'info', 0); try { const payload = { [PRIMARY_KEY_COLUMN]: orderId, [columnKey]: newValue }; const response = await fetch(SINGLE_UPDATE_API_URL, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const result = await response.json(); if (result.success) { const originalRowIndex = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === orderId); if (originalRowIndex !== -1) { state.allData[originalRowIndex] = { ...state.allData[originalRowIndex], [columnKey]: newValue }; } const orderChanges = state.pendingChanges.get(orderId); if (orderChanges) { orderChanges.delete(columnKey); if (orderChanges.size === 0) { state.pendingChanges.delete(orderId); } } cellElement.classList.remove('highlight'); savePendingChangesToLocalStorage(); removeToast(loadingToast); showCustomAlert('C·∫≠p nh·∫≠t th√†nh c√¥ng!', 'success', 2000); } else { removeToast(loadingToast); showCustomAlert(`L·ªói c·∫≠p nh·∫≠t: ${result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (error) { console.error('L·ªói khi c·∫≠p nh·∫≠t ƒë∆°n l·∫ª:', error); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); } finally { isUpdatingSingleCell = false; document.getElementById('updateAll').disabled = false; } }

        // --- Tabs v√† Filters ---
        function createTabs(data) { /* ... Gi·ªØ nguy√™n ... */ const tabContainer = document.getElementById('tabContainer'); tabContainer.innerHTML = ''; const teams = [...new Set(data.map(row => row[TEAM_COLUMN_NAME]).filter(Boolean))].sort(); const createTab = (name, value) => { const button = document.createElement('button'); button.className = 'tab-btn'; button.textContent = name; button.dataset.team = value; if (value === state.activeTeam) { button.classList.add('active'); } button.addEventListener('click', async () => { state.activeTeam = value; state.currentPage = 1; document.querySelectorAll('#tabContainer .tab-btn').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); if (value === 'mgt_noi_bo' && state.mgtNoiBoOrder.length === 0 && !state.isMgtNoiBoOrderLoading) { await fetchMGTNoiBoOrder(); } render(); }); return button; }; tabContainer.appendChild(createTab('T·∫•t c·∫£', 'all')); tabContainer.appendChild(createTab('MGT n·ªôi b·ªô', 'mgt_noi_bo')); teams.forEach(team => tabContainer.appendChild(createTab(team, team))); }

        function setupColumnFilters() {
            const filterRow = document.getElementById('filterRow');
            filterRow.innerHTML = '';
            const storedFilterValues = localStorage.getItem('speegoColumnFilters');
            if (storedFilterValues) {
                try {
                    // Gi·ªØ l·∫°i gi√° tr·ªã c·ªßa market v√† product t·ª´ state
                    const parsedFilters = JSON.parse(storedFilterValues);
                    state.filterValues = { ...parsedFilters, market: state.filterValues.market, product: state.filterValues.product };
                } catch (e) {
                    console.error("L·ªói khi ƒë·ªçc filterValues t·ª´ localStorage:", e);
                    state.filterValues = { market: [], product: [] };
                }
            }

            displayColumns.forEach((col) => {
                const th = document.createElement('th');

                if (col === "M√£ Tracking") {
                    const container = document.createElement('div');
                    container.className = 'dual-filter-container';
                    const includeInput = document.createElement('input');
                    includeInput.type = 'text';
                    includeInput.className = 'filter-input';
                    includeInput.placeholder = 'Bao g·ªìm...';
                    includeInput.value = state.filterValues['tracking_include'] || '';
                    includeInput.addEventListener('input', () => {
                        state.filterValues['tracking_include'] = includeInput.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1;
                        render();
                    });
                    const excludeInput = document.createElement('input');
                    excludeInput.type = 'text';
                    excludeInput.className = 'filter-input';
                    excludeInput.placeholder = 'Lo·∫°i tr·ª´...';
                    excludeInput.value = state.filterValues['tracking_exclude'] || '';
                    excludeInput.addEventListener('input', () => {
                        state.filterValues['tracking_exclude'] = excludeInput.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1;
                        render();
                    });
                    container.appendChild(includeInput);
                    container.appendChild(excludeInput);
                    th.appendChild(container);
                } else if (col === "Tr·∫°ng th√°i giao h√†ng") {
                    // --- B·∫ÆT ƒê·∫¶U PH·∫¶N TH√äM M·ªöI ---
                    const dataKey = columnMapping[col] || col;
                    const ALL_OPTION_TEXT = 'T·∫•t c·∫£';
                    const EMPTY_OPTION_TEXT = '(Tr·ªëng)';
                    const EMPTY_OPTION_VALUE = '__EMPTY__'; // Gi√° tr·ªã ƒë·∫∑c bi·ªát ƒë·ªÉ ƒë·∫°i di·ªán cho √¥ tr·ªëng

                    const container = document.createElement('div');
                    container.className = 'multiselect-filter';

                    const display = document.createElement('button');
                    display.className = 'multiselect-display';

                    const dropdown = document.createElement('div');
                    dropdown.className = 'multiselect-dropdown';

                    // L·∫•y c√°c gi√° tr·ªã duy nh·∫•t t·ª´ d·ªØ li·ªáu
                    const uniqueStatuses = [...new Set(state.allData.map(row => (row[dataKey] || '').trim()).filter(Boolean))].sort();
                    const options = [ALL_OPTION_TEXT, EMPTY_OPTION_TEXT, ...uniqueStatuses];

                    let selectedValues = state.filterValues[dataKey] || [];

                    const updateDisplay = () => {
                        if (selectedValues.length === 0 || selectedValues.length === (uniqueStatuses.length + 1)) { // +1 cho l·ª±a ch·ªçn (Tr·ªëng)
                            display.textContent = 'L·ªçc ' + col;
                            if (selectedValues.length === (uniqueStatuses.length + 1)) {
                                //N·∫øu t·∫•t c·∫£ ƒë∆∞·ª£c ch·ªçn (tr·ª´ "T·∫•t c·∫£"), coi nh∆∞ kh√¥ng l·ªçc
                                state.filterValues[dataKey] = [];
                            }
                        } else if (selectedValues.length === 1) {
                            if (selectedValues[0] === EMPTY_OPTION_VALUE) {
                                display.textContent = EMPTY_OPTION_TEXT;
                            } else {
                                display.textContent = selectedValues[0];
                            }
                        } else {
                            display.textContent = `${selectedValues.length} ƒë√£ ch·ªçn`;
                        }
                    };

                    options.forEach(optionText => {
                        const item = document.createElement('div');
                        item.className = 'multiselect-item';
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        const label = document.createElement('label');

                        checkbox.id = `filter-${dataKey}-${optionText}`;
                        label.htmlFor = `filter-${dataKey}-${optionText}`;
                        label.textContent = optionText;

                        let optionValue = optionText;
                        if (optionText === EMPTY_OPTION_TEXT) optionValue = EMPTY_OPTION_VALUE;

                        if (optionText === ALL_OPTION_TEXT) {
                            checkbox.checked = selectedValues.length === (uniqueStatuses.length + 1);
                        } else {
                            checkbox.checked = selectedValues.includes(optionValue);
                        }

                        item.appendChild(checkbox);
                        item.appendChild(label);
                        dropdown.appendChild(item);
                    });

                    dropdown.addEventListener('change', (e) => {
                        const targetCheckbox = e.target;
                        const optionText = targetCheckbox.parentElement.textContent;
                        let optionValue = optionText;
                        if (optionText === EMPTY_OPTION_TEXT) optionValue = EMPTY_OPTION_VALUE;

                        if (optionText === ALL_OPTION_TEXT) {
                            const allCheckboxes = dropdown.querySelectorAll('input[type="checkbox"]');
                            selectedValues = [];
                            if (targetCheckbox.checked) {
                                allCheckboxes.forEach(cb => {
                                    cb.checked = true;
                                    const text = cb.parentElement.textContent;
                                    if (text !== ALL_OPTION_TEXT) {
                                        selectedValues.push(text === EMPTY_OPTION_TEXT ? EMPTY_OPTION_VALUE : text);
                                    }
                                });
                            } else {
                                allCheckboxes.forEach(cb => cb.checked = false);
                            }
                        } else {
                            if (targetCheckbox.checked) {
                                if (!selectedValues.includes(optionValue)) {
                                    selectedValues.push(optionValue);
                                }
                            } else {
                                selectedValues = selectedValues.filter(v => v !== optionValue);
                            }
                            // C·∫≠p nh·∫≠t checkbox "T·∫•t c·∫£"
                            const allCheckbox = dropdown.querySelector(`input[id="filter-${dataKey}-${ALL_OPTION_TEXT}"]`);
                            allCheckbox.checked = selectedValues.length === uniqueStatuses.length + 1;
                        }

                        state.filterValues[dataKey] = selectedValues;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        updateDisplay();
                        state.currentPage = 1;
                        render();
                    });

                    display.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // ƒê√≥ng c√°c dropdown kh√°c tr∆∞·ªõc khi m·ªü dropdown n√†y
                        document.querySelectorAll('.multiselect-dropdown.show').forEach(d => {
                            if (d !== dropdown) d.classList.remove('show');
                        });
                        dropdown.classList.toggle('show');
                    });

                    container.appendChild(display);
                    container.appendChild(dropdown);
                    th.appendChild(container);
                    updateDisplay();
                    // --- K·∫æT TH√öC PH·∫¶N TH√äM M·ªöI ---
                } else if(["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) {
                    const input = document.createElement('input');
                    input.type = 'date';
                    input.className = 'filter-input date-filter-input';
                    input.placeholder = `L·ªçc ${col}`;
                    input.dataset.column = col;
                    input.value = state.filterValues[col] || '';
                    input.addEventListener('change', () => {
                        state.filterValues[col] = input.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1;
                        render();
                    });
                    th.appendChild(input);
                } else {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'filter-input';
                    input.placeholder = `L·ªçc ${col}`;
                    input.dataset.column = col;
                    input.value = state.filterValues[col] || '';
                    input.addEventListener('input', () => {
                        state.filterValues[col] = input.value;
                        localStorage.setItem('speegoColumnFilters', JSON.stringify(state.filterValues));
                        state.currentPage = 1;
                        render();
                    });
                    th.appendChild(input);
                }
                filterRow.appendChild(th);
            });

            // Th√™m event listener ƒë·ªÉ ƒë√≥ng dropdown khi click ra ngo√†i
            document.addEventListener('click', (e) => {
                document.querySelectorAll('.multiselect-dropdown.show').forEach(dropdown => {
                    if (!dropdown.parentElement.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            });
        }

        // M·ªöI: C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng tr√™n badge c·ªßa n√∫t ƒë·ªìng b·ªô
        function updateSyncButtonBadge() {
            const badge = document.getElementById('changesBadge');
            const totalChanges = state.legacyChanges.size + state.pendingChanges.size;
            if (totalChanges > 0) {
                badge.textContent = totalChanges;
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }
        }

        // --- C√ÅC H√ÄM ƒêI·ªÄU KHI·ªÇN ---
        function setupControls() {
            document.getElementById('refreshData').addEventListener('click', refreshData);
            document.getElementById('updateAll').addEventListener('click', updateAllChangedRows);
            document.getElementById('toggleTrackingView').addEventListener('click', () => { toggleTrackingView(); state.currentPage = 1; });
            // <-- EVENT LISTENER M·ªöI -->
            document.getElementById('toggleDuplicateTrackingView').addEventListener('click', () => { toggleDuplicateTrackingView(); state.currentPage = 1; });

            // C·∫¨P NH·∫¨T: X√≥a c√°c event listener c≈© cho filter market/product
            // Ch√∫ng ƒë∆∞·ª£c x·ª≠ l√Ω trong h√†m `populateMainFilters`
            document.getElementById('filterDateFrom').addEventListener('change', () => { state.currentPage = 1; render(); });
            document.getElementById('filterDateTo').addEventListener('change', () => { state.currentPage = 1; render(); });

            document.getElementById('downloadExcel').addEventListener('click', downloadAsExcel);
            document.getElementById('fixedColumns').addEventListener('change', updateFixedColumns);
            document.getElementById('clearFiltersBtn').addEventListener('click', clearAllFilters);
            document.getElementById('transferWarehouseBtn').addEventListener('click', transferSelectedOrders);
            document.getElementById('prevPage').addEventListener('click', () => { if (state.currentPage > 1) { state.currentPage--; render(); } });
            document.getElementById('nextPage').addEventListener('click', () => { const totalPages = Math.ceil(state.totalFilteredOrders / state.rowsPerPage); if (state.currentPage < totalPages) { state.currentPage++; render(); } });
            document.getElementById('rowsPerPageSelect').addEventListener('change', (e) => { state.rowsPerPage = parseInt(e.target.value, 10); state.currentPage = 1; render(); });

            // M·ªöI: Event listeners cho popover
            const popover = document.getElementById('syncPopover');
            document.getElementById('syncChangesBtn').addEventListener('click', showSyncPopover);
            document.getElementById('closePopoverBtn').addEventListener('click', () => popover.style.display = 'none');
            document.getElementById('applyAllChangesBtn').addEventListener('click', () => {
                updateAllChangedRows();
                popover.style.display = 'none';
            });
            document.getElementById('discardAllChangesBtn').addEventListener('click', () => {
                if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën h·ªßy b·ªè T·∫§T C·∫¢ c√°c thay ƒë·ªïi ch∆∞a ƒë∆∞·ª£c l∆∞u? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
                    state.pendingChanges.clear();
                    state.legacyChanges.clear();
                    localStorage.removeItem('speegoPendingChanges');
                    updateSyncButtonBadge();
                    render();
                    popover.style.display = 'none';
                    showCustomAlert('ƒê√£ h·ªßy b·ªè t·∫•t c·∫£ thay ƒë·ªïi. ƒêang t·∫£i l·∫°i d·ªØ li·ªáu...', 'info');
                    //ƒë·ª£i m·ªôt ch√∫t r·ªìi t·∫£i l·∫°i d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
                    setTimeout(() => { refreshData(); }, 500);
                }
            });
            popover.addEventListener('click', (e) => {
                if (e.target === popover) {
                    popover.style.display = 'none';
                }
            });
        }

        function clearAllFilters() {
            // X√≥a filter values t·ª´ state
            state.filterValues = {
                market: [],
                product: []
            };

            // X√≥a t·ª´ localStorage
            localStorage.removeItem('speegoColumnFilters');

            // Reset c√°c filter input trong b·∫£ng
            document.querySelectorAll('#filterRow .filter-input').forEach(input => {
                input.value = '';
            });

            // Reset c√°c dropdown filter trong b·∫£ng
            document.querySelectorAll('#filterRow .multiselect-display').forEach(display => {
                // Gi·∫£ s·ª≠ logic reset s·∫Ω ƒë∆∞·ª£c g·ªçi khi render l·∫°i
            });

            // Reset c√°c filter ch√≠nh (main filters)
            document.getElementById('filterDateFrom').value = '';
            document.getElementById('filterDateTo').value = '';

            // C·∫≠p nh·∫≠t l·∫°i UI c·ªßa multi-select filter
            const initialDataForFilters = filterByCarrier(state.allData);
            populateMainFilters(initialDataForFilters);
            setupColumnFilters();


            // Reset v·ªÅ trang ƒë·∫ßu v√† render l·∫°i
            state.currentPage = 1;
            render();

            // Hi·ªÉn th·ªã th√¥ng b√°o
            showCustomAlert('ƒê√£ x√≥a t·∫•t c·∫£ b·ªô l·ªçc!', 'success');
        }

        async function loadData() { /* ... Gi·ªØ nguy√™n ... */ document.getElementById('tableBody').innerHTML = `<tr><td colspan="${displayColumns.length}" style="text-align: center;">ƒêang t·∫£i...</td></tr>`; try { const response = await fetch(`${mainHost}/sheet/${SHEET_NAME}/data`, { method: 'GET', headers: { 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const data = await response.json(); handleData(data); } catch (error) { console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', error); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); document.getElementById('refreshData').disabled = false; document.getElementById('refreshData').innerHTML = '<span class="refresh-icon">‚Üª</span> Load d·ªØ li·ªáu'; } }

        async function refreshData() {
            if (isUpdatingSingleCell) { showCustomAlert('ƒêang c√≥ thao t√°c c·∫≠p nh·∫≠t ƒë∆°n l·∫ª, vui l√≤ng ƒë·ª£i.', 'info'); return; }
            const btn = document.getElementById('refreshData');
            btn.disabled = true;
            btn.innerHTML = '<span class="refresh-icon">‚Üª</span> ƒêang t·∫£i...';

            state.activeTeam = 'all';
            state.filterValues = { market: [], product: [] }; // C·∫¨P NH·∫¨T
            localStorage.removeItem('speegoColumnFilters');
            state.mgtNoiBoOrder = [];
            state.currentPage = 1;

            // S·ª¨A ƒê·ªîI: Kh√¥ng x√≥a pendingChanges khi refresh, ch·ªâ load l·∫°i data n·ªÅn
            state.pendingChanges.clear();
            // state.legacyChanges v·∫´n gi·ªØ nguy√™n

            document.getElementById('tabContainer').innerHTML = '';
            document.getElementById('filterRow').innerHTML = '';
            document.getElementById('mainFilters').querySelectorAll('input').forEach(el => { if (el.id !== 'fixedColumns') el.value = ''; });
            updateOrderCounter(0);
            await loadData(); // loadData s·∫Ω t·ª± g·ªçi loadPendingChangesFromLocalStorage
        }

        async function updateAllChangedRows() {
            if (isUpdatingSingleCell) { showCustomAlert('ƒêang c√≥ thao t√°c c·∫≠p nh·∫≠t ƒë∆°n l·∫ª, vui l√≤ng ƒë·ª£i.', 'info'); return; }

            // S·ª¨A ƒê·ªîI: G·ªôp 2 lo·∫°i thay ƒë·ªïi l·∫°i ƒë·ªÉ g·ª≠i ƒëi
            const allChanges = new Map([...state.legacyChanges, ...state.pendingChanges]);

            if (allChanges.size === 0) {
                showCustomAlert('Kh√¥ng c√≥ thay ƒë·ªïi c·∫ßn c·∫≠p nh·∫≠t.', 'info');
                return;
            }

            const updateBtn = document.getElementById('updateAll');
            updateBtn.disabled = true;
            updateBtn.textContent = 'ƒêang g·ª≠i...';
            const loadingToast = showCustomAlert('ƒêang c·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi...', 'info', 0);

            const rowsToSend = [];
            allChanges.forEach((changes, orderId) => {
                const changeObject = { [PRIMARY_KEY_COLUMN]: orderId };
                changes.forEach((changeInfo, colName) => {
                    changeObject[colName] = changeInfo.newValue;
                });
                rowsToSend.push(changeObject);
            });

            try {
                const response = await fetch(BATCH_UPDATE_API_URL, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(rowsToSend) });
                if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); }
                const json = await response.json();

                if (json.success) {
                    removeToast(loadingToast);
                    showCustomAlert(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${json.summary.updated} ƒë∆°n h√†ng!`, 'success');
                    json.details.forEach(detail => {
                        if (detail.status === 'updated') {
                            const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey);
                            if (updatedRowData) {
                                const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (index !== -1) { state.allData[index] = { ...state.allData[index], ...updatedRowData }; }
                            }
                        }
                    });

                    // S·ª¨A ƒê·ªîI: X√≥a c·∫£ 2 lo·∫°i thay ƒë·ªïi
                    state.pendingChanges.clear();
                    state.legacyChanges.clear();
                    savePendingChangesToLocalStorage();
                    render();
                } else { removeToast(loadingToast); showCustomAlert(`L·ªói: ${json.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); }
            } catch (error) { console.error('L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t:', error); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error'); } finally { updateBtn.disabled = false; updateBtn.textContent = 'C·∫≠p nh·∫≠t t·∫•t c·∫£ thay ƒë·ªïi'; }
        }

        // TH√äM M·ªöI: Function ki·ªÉm tra c√≥ thay ƒë·ªïi M√£ Tracking kh√¥ng
        function hasTrackingChanges(rowsToSend) {
            return rowsToSend.some(row => {
                return Object.keys(row).some(key =>
                    key === "M√£ Tracking" || key === "M√£_Tracking"
                );
            });
        }

        async function batchUpdatePastedData(rowsToSend) {
            if (rowsToSend.length === 0) { return; }

            // TH√äM M·ªöI: Ki·ªÉm tra n·∫øu c√≥ thay ƒë·ªïi M√£ Tracking
            const hasTracking = hasTrackingChanges(rowsToSend);

            if (hasTracking) {
                // N·∫øu c√≥ thay ƒë·ªïi M√£ Tracking, ch·ªâ l∆∞u v√†o pending changes, kh√¥ng g·ª≠i API
                rowsToSend.forEach(rowData => {
                    const orderId = rowData[PRIMARY_KEY_COLUMN];
                    if (!orderId) return;

                    if (!state.pendingChanges.has(orderId)) {
                        state.pendingChanges.set(orderId, new Map());
                    }

                    Object.keys(rowData).forEach(colName => {
                        if (colName !== PRIMARY_KEY_COLUMN) {
                            const originalRowData = state.allData.find(r => r[PRIMARY_KEY_COLUMN] === orderId);
                            const originalValue = originalRowData ? String(originalRowData[colName] ?? '') : '';

                            state.pendingChanges.get(orderId).set(colName, {
                                newValue: rowData[colName],
                                originalValue: originalValue,
                                cellElement: null
                            });
                        }
                    });
                });

                savePendingChangesToLocalStorage();
                showCustomAlert(`ƒê√£ l∆∞u ${rowsToSend.length} thay ƒë·ªïi c√≥ ch·ª©a M√£ Tracking. Vui l√≤ng b·∫•m "C·∫≠p nh·∫≠t t·∫•t c·∫£" ƒë·ªÉ g·ª≠i d·ªØ li·ªáu.`, 'info', 5000);
                render(); // Refresh ƒë·ªÉ hi·ªÉn th·ªã highlight
                return;
            }

            // Logic c≈© cho c√°c thay ƒë·ªïi kh√¥ng c√≥ M√£ Tracking
            const updateBtn = document.getElementById('updateAll');
            updateBtn.disabled = true;
            const loadingToast = showCustomAlert(`ƒêang c·∫≠p nh·∫≠t ${rowsToSend.length} thay ƒë·ªïi ƒë√£ d√°n...`, 'info', 0);

            try {
                const response = await fetch(BATCH_UPDATE_API_URL, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(rowsToSend)
                });

                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`);
                }

                const json = await response.json();

                if (json.success) {
                    removeToast(loadingToast);
                    showCustomAlert(`C·∫≠p nh·∫≠t th√†nh c√¥ng ${json.summary?.updated || rowsToSend.length} ƒë∆°n h√†ng t·ª´ d·ªØ li·ªáu ƒë√£ d√°n!`, 'success');

                    json.details?.forEach(detail => {
                        if (detail.status === 'updated') {
                            const updatedRowData = rowsToSend.find(r => r[PRIMARY_KEY_COLUMN] === detail.primaryKey);
                            if (updatedRowData) {
                                const index = state.allData.findIndex(r => r[PRIMARY_KEY_COLUMN] === updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (index !== -1) {
                                    state.allData[index] = { ...state.allData[index], ...updatedRowData };
                                }

                                const orderChanges = state.pendingChanges.get(updatedRowData[PRIMARY_KEY_COLUMN]);
                                if (orderChanges) {
                                    Object.keys(updatedRowData).forEach(colName => {
                                        if (colName !== PRIMARY_KEY_COLUMN) {
                                            orderChanges.delete(colName);
                                        }
                                    });
                                    if (orderChanges.size === 0) {
                                        state.pendingChanges.delete(updatedRowData[PRIMARY_KEY_COLUMN]);
                                    }
                                }
                            }
                        }
                    });

                    savePendingChangesToLocalStorage();
                    render();
                } else {
                    removeToast(loadingToast);
                    showCustomAlert(`L·ªói c·∫≠p nh·∫≠t h√†ng lo·∫°t: ${json.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error');
                }
            } catch (error) {
                console.error('L·ªói khi c·∫≠p nh·∫≠t h√†ng lo·∫°t t·ª´ paste:', error);
                removeToast(loadingToast);
                showCustomAlert(`L·ªói k·∫øt n·ªëi: ${error.message}`, 'error');
            } finally {
                updateBtn.disabled = false;
            }
        }

        // H√ÄM ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T
        function toggleTrackingView() {
            state.showTrackingOrders = !state.showTrackingOrders;
            // N·∫øu b·∫≠t ch·∫ø ƒë·ªô n√†y, t·∫Øt ch·∫ø ƒë·ªô xem tr√πng
            if (state.showTrackingOrders) {
                state.showDuplicateTrackingOrders = false;
            }
            updateTrackingButtonsUI();
            render();
        }

        // H√ÄM M·ªöI
        function toggleDuplicateTrackingView() {
            state.showDuplicateTrackingOrders = !state.showDuplicateTrackingOrders;
            // N·∫øu b·∫≠t ch·∫ø ƒë·ªô n√†y, t·∫Øt ch·∫ø ƒë·ªô xem c√≥/kh√¥ng c√≥ tracking
            if (state.showDuplicateTrackingOrders) {
                state.showTrackingOrders = false;
            }
            updateTrackingButtonsUI();
            render();
        }

        // H√ÄM M·ªöI: ƒê·ªìng b·ªô giao di·ªán c√°c n√∫t tracking
        function updateTrackingButtonsUI() {
            const trackingBtn = document.getElementById('toggleTrackingView');
            const duplicateBtn = document.getElementById('toggleDuplicateTrackingView');

            // C·∫≠p nh·∫≠t n√∫t xem ƒë∆°n c√≥/kh√¥ng c√≥ tracking
            if (state.showTrackingOrders) {
                trackingBtn.textContent = 'Xem ƒë∆°n kh√¥ng c√≥ m√£ Tracking';
                trackingBtn.classList.add('active');
            } else {
                trackingBtn.textContent = 'Xem ƒë∆°n c√≥ m√£ Tracking';
                trackingBtn.classList.remove('active');
            }

            // C·∫≠p nh·∫≠t n√∫t xem ƒë∆°n tr√πng
            if (state.showDuplicateTrackingOrders) {
                duplicateBtn.textContent = 'Xem t·∫•t c·∫£ ƒë∆°n';
                duplicateBtn.classList.add('active');
            } else {
                duplicateBtn.textContent = 'Xem ƒë∆°n tr√πng M√£ tracking';
                duplicateBtn.classList.remove('active');
            }
        }

        function getCellValue(cell) { /* ... Gi·ªØ nguy√™n ... */ if (!cell) return ''; const select = cell.querySelector('select'); if (select) return select.value; const input = cell.querySelector('input'); return input ? input.value : cell.textContent; }
        function setCellValue(cell, value) { /* ... Gi·ªØ nguy√™n ... */ if (!cell) return; const select = cell.querySelector('select'); if (select) { select.value = value; select.dispatchEvent(new Event('change', { bubbles: true })); return; } const input = cell.querySelector('input'); if (input) { input.value = value; input.dispatchEvent(new Event('blur', { bubbles: true })); return; } if (cell.isContentEditable) { cell.textContent = value; cell.dispatchEvent(new Event('blur', { bubbles: true })); } }
        function clearAllSelections() { /* ... Gi·ªØ nguy√™n ... */ document.querySelectorAll('td.cell-selected').forEach(c => c.classList.remove('cell-selected')); if (pasteAnchorCell) { pasteAnchorCell.classList.remove('paste-anchor'); pasteAnchorCell = null; } updateSelectionSummary(); }
        function updateSelectionSummary() { /* ... Gi·ªØ nguy√™n ... */ const summaryEl = document.getElementById('selectionSummary'); const transferBtn = document.getElementById('transferWarehouseBtn'); const selectedCells = document.querySelectorAll('td.cell-selected'); summaryEl.innerHTML = ''; const selectedOrderIds = new Set(); const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN); if (selectedCells.length === 0) { transferBtn.style.display = 'none'; transferBtn.disabled = true; return; } const numericKeywords = ["s·ªë l∆∞·ª£ng", "gi√°", "ti·ªÅn", "ph√≠", "zipcode"]; const columns = new Map(); selectedCells.forEach(cell => { const colIndex = cell.cellIndex; if (colIndex === orderIdColIndex) { const orderId = getCellValue(cell).trim(); if (orderId) { selectedOrderIds.add(orderId); } } if (!columns.has(colIndex)) { columns.set(colIndex, []); } columns.get(colIndex).push(cell); }); const summaryParts = []; columns.forEach((cells, colIndex) => { const headerText = displayColumns[colIndex].toLowerCase(); const isNumeric = numericKeywords.some(kw => headerText.includes(kw)); if (isNumeric) { let sum = 0; let count = 0; cells.forEach(cell => { const value = getCellValue(cell); const num = parseFloat(String(value).replace(/[^\d.-]/g, '')); if (!isNaN(num)) { sum += num; count++; } }); if (count > 0) { summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Sum: <b>${sum.toLocaleString('vi-VN')}</b></span>`); } } else { let count = 0; cells.forEach(cell => { if (getCellValue(cell).trim() !== '') { count++; } }); if (count > 0) { summaryParts.push(`<span class="summary-item">${displayColumns[colIndex]} | Count: <b>${count}</b></span>`); } } }); summaryEl.innerHTML = summaryParts.join(''); if (selectedOrderIds.size > 0) { transferBtn.style.display = 'block'; transferBtn.disabled = false; } else { transferBtn.style.display = 'none'; transferBtn.disabled = true; } }
        async function transferSelectedOrders() { /* ... Gi·ªØ nguy√™n ... */ const transferBtn = document.getElementById('transferWarehouseBtn'); const originalText = transferBtn.textContent; transferBtn.disabled = true; transferBtn.textContent = 'ƒêang chuy·ªÉn...'; const loadingToast = showCustomAlert('ƒêang chuy·ªÉn kho...', 'info', 0); const selectedOrderIds = new Set(); const orderIdColIndex = displayColumns.indexOf(PRIMARY_KEY_COLUMN); document.querySelectorAll('td.cell-selected').forEach(cell => { if (cell.cellIndex === orderIdColIndex) { const orderId = getCellValue(cell).trim(); if (orderId) { selectedOrderIds.add({ "M√£ ƒë∆°n h√†ng": orderId }); } } }); if (selectedOrderIds.size === 0) { removeToast(loadingToast); showCustomAlert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt "M√£ ƒë∆°n h√†ng" ƒë·ªÉ chuy·ªÉn kho.', 'info'); transferBtn.disabled = false; transferBtn.textContent = originalText; return; } const maDonList = Array.from(selectedOrderIds); try { const response = await fetch(TRANSFER_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ rows: maDonList }) }); if (!response.ok) { const errorResponse = await response.json(); throw new Error(errorResponse.message || `L·ªói HTTP! status: ${response.status}`); } const result = await response.json(); if (result && result.success) { clearAllSelections(); removeToast(loadingToast); showCustomAlert('Chuy·ªÉn kho th√†nh c√¥ng!', 'success', 2000); await fetchMGTNoiBoOrder(); render(); } else { removeToast(loadingToast); showCustomAlert(`Chuy·ªÉn kho kh√¥ng th√†nh c√¥ng: ${result.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.'}`, 'error'); } } catch (e) { console.error('L·ªói khi chuy·ªÉn kho:', e); removeToast(loadingToast); showCustomAlert(`L·ªói k·∫øt n·ªëi ho·∫∑c x·ª≠ l√Ω: ${e.message}`, 'error'); } finally { transferBtn.disabled = false; transferBtn.textContent = originalText; } }
        function setupInteractionHandlers() {
            const tableBody = document.getElementById('tableBody');
            if (!tableBody) return;
            let isSelecting = false, startCell = null;

            const selectCells = (start, end) => {
                clearAllSelections();
                const tableRows = tableBody.rows;
                const minRow = Math.min(start.parentElement.rowIndex, end.parentElement.rowIndex);
                const maxRow = Math.max(start.parentElement.rowIndex, end.parentElement.rowIndex);
                const minCol = Math.min(start.cellIndex, end.cellIndex);
                const maxCol = Math.max(start.cellIndex, end.cellIndex);

                for (let i = 0; i < tableRows.length; i++) {
                    const row = tableRows[i];
                    if (row.rowIndex >= minRow && row.rowIndex <= maxRow) {
                        for (let j = minCol; j <= maxCol; j++) {
                            if (row.cells[j]) row.cells[j].classList.add('cell-selected');
                        }
                    }
                }

                if (start) {
                    pasteAnchorCell = start;
                    start.classList.add('paste-anchor');
                }
            };

            tableBody.addEventListener('mousedown', e => {
                if (e.button !== 0) return;
                const cell = e.target.closest('td');
                if (!cell) return;
                e.preventDefault();

                if (e.shiftKey && pasteAnchorCell) {
                    selectCells(pasteAnchorCell, cell);
                    updateSelectionSummary();
                } else {
                    isSelecting = true;
                    clearAllSelections();
                    startCell = cell;
                    pasteAnchorCell = cell;
                    cell.classList.add('cell-selected');
                    cell.classList.add('paste-anchor');
                    updateSelectionSummary();
                }
            });

            tableBody.addEventListener('mousemove', e => {
                if (!isSelecting || !startCell) return;
                const currentCell = e.target.closest('td');
                if (currentCell && currentCell !== startCell) {
                    selectCells(startCell, currentCell);
                }
            });

            document.addEventListener('mouseup', () => {
                if (isSelecting) {
                    isSelecting = false;
                    updateSelectionSummary();
                }
            });

            tableBody.addEventListener('dblclick', e => {
                const cell = e.target.closest('td.editable');
                if (!cell) return;

                const input = cell.querySelector('input, select');
                if (input) {
                    input.focus();
                } else if (cell.isContentEditable) {
                    cell.focus();
                    document.execCommand('selectAll', false, null);
                    document.getSelection().collapseToEnd();
                }
            });

            document.addEventListener('copy', e => {
                const selectedCells = document.querySelectorAll('td.cell-selected');
                if (selectedCells.length === 0) return;

                e.preventDefault();
                const rows = new Map();

                selectedCells.forEach(cell => {
                    const rowIndex = cell.parentElement.rowIndex;
                    if (!rows.has(rowIndex)) rows.set(rowIndex, []);
                    rows.get(rowIndex).push({ colIndex: cell.cellIndex, text: getCellValue(cell) });
                });

                const sortedRows = [...rows.entries()].sort((a, b) => a[0] - b[0]);
                const copyText = sortedRows.map(([, cells]) =>
                    cells.sort((a, b) => a.colIndex - b.colIndex).map(cell => cell.text).join('\t')
                ).join('\n');

                e.clipboardData.setData('text/plain', copyText);
                showCustomAlert(`ƒê√£ sao ch√©p ${selectedCells.length} √¥.`, 'info', 2000);
            });

            document.addEventListener('paste', e => {
                const activeEl = document.activeElement;
                if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) {
                    return;
                }
                if (!pasteAnchorCell) return;

                e.preventDefault();
                const pasteData = e.clipboardData.getData('text/plain');
                if (!pasteData) return;

                const pastedRows = pasteData.split(/\r\n?|\n/)
                    .map(row => row.split('\t'));

                if (pastedRows.length === 0) return;

                // X·ª≠ l√Ω paste gi√° tr·ªã ƒë∆°n v√†o nhi·ªÅu √¥ ƒë∆∞·ª£c ch·ªçn
                if (pastedRows.length === 1 && pastedRows[0].length === 1) {
                    const singleValue = pastedRows[0][0];
                    const editableSelected = document.querySelectorAll('td.cell-selected.editable');

                    if (editableSelected.length > 0) {
                        // Thu th·∫≠p t·∫•t c·∫£ th√¥ng tin t·ª´ selected cells v√† map ƒë√∫ng M√£ ƒë∆°n h√†ng
                        const changesForBatchUpdate = new Map();
                        isPasting = true;

                        editableSelected.forEach(cell => {
                            const targetRow = cell.parentElement;
                            const orderId = targetRow.dataset.orderId;
                            if (!orderId) return;

                            const colIndex = cell.cellIndex;
                            const colName = displayColumns[colIndex];
                            const dataKey = columnMapping[colName] || colName;

                            // ƒê·∫£m b·∫£o ƒë√¢y l√† c·ªôt c√≥ th·ªÉ ch·ªânh s·ª≠a
                            if (!editableCols.includes(colName)) return;

                            // C·∫≠p nh·∫≠t gi√° tr·ªã trong UI
                            setCellValue(cell, singleValue);

                            // Chu·∫©n b·ªã d·ªØ li·ªáu cho API v·ªõi M√£ ƒë∆°n h√†ng l√†m kh√≥a ch√≠nh
                            if (!changesForBatchUpdate.has(orderId)) {
                                changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId });
                            }

                            let valueForApi = singleValue;
                            if (colName === "Ng√†y ƒë√≥ng h√†ng") {
                                valueForApi = parseDateToISO(singleValue);
                            }
                            changesForBatchUpdate.get(orderId)[dataKey] = valueForApi;
                        });

                        isPasting = false;

                        // G·ª≠i batch update cho t·∫•t c·∫£ thay ƒë·ªïi
                        const rowsToSend = Array.from(changesForBatchUpdate.values());
                        if (rowsToSend.length > 0) {
                            const hasTracking = hasTrackingChanges(rowsToSend);
                            batchUpdatePastedData(rowsToSend);

                            if (!hasTracking) {
                                showCustomAlert(`ƒê√£ d√°n gi√° tr·ªã v√†o ${editableSelected.length} √¥ v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 3000);
                            }
                        }
                        updateSelectionSummary();
                        return;
                    }
                }

                // X·ª≠ l√Ω paste d·ªØ li·ªáu b·∫£ng (nhi·ªÅu d√≤ng, nhi·ªÅu c·ªôt)
                const tableRows = Array.from(document.getElementById('tableBody').rows);
                let startRowIndex = tableRows.findIndex(row => row.rowIndex === pasteAnchorCell.parentElement.rowIndex);
                let startColIndex = pasteAnchorCell.cellIndex;

                if (startRowIndex < 0 || startColIndex < 0) return;

                const changesForBatchUpdate = new Map();
                isPasting = true;

                pastedRows.forEach((rowData, i) => {
                    const targetRow = tableRows[startRowIndex + i];
                    if (!targetRow) return;

                    const orderId = targetRow.dataset.orderId;
                    if (!orderId) return;

                    // Kh·ªüi t·∫°o object cho ƒë∆°n h√†ng n√†y v·ªõi M√£ ƒë∆°n h√†ng l√†m kh√≥a ch√≠nh
                    if (!changesForBatchUpdate.has(orderId)) {
                        changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId });
                    }

                    rowData.forEach((cellData, j) => {
                        const targetCell = targetRow.cells[startColIndex + j];
                        if (targetCell && targetCell.classList.contains('editable')) {
                            const colName = displayColumns[startColIndex + j];
                            const dataKey = columnMapping[colName] || colName;

                            // C·∫≠p nh·∫≠t UI
                            setCellValue(targetCell, cellData);

                            // Chu·∫©n b·ªã d·ªØ li·ªáu cho API
                            let valueForApi = cellData;
                            if (colName === "Ng√†y ƒë√≥ng h√†ng") {
                                valueForApi = parseDateToISO(cellData);
                            }
                            changesForBatchUpdate.get(orderId)[dataKey] = valueForApi;
                        }
                    });
                });

                isPasting = false;

                // G·ª≠i t·∫•t c·∫£ thay ƒë·ªïi qua batch update v·ªõi mapping ƒë√∫ng M√£ ƒë∆°n h√†ng
                const rowsToSend = Array.from(changesForBatchUpdate.values());
                if (rowsToSend.length > 0) {
                    const hasTracking = hasTrackingChanges(rowsToSend);
                    batchUpdatePastedData(rowsToSend);

                    if (!hasTracking) {
                        showCustomAlert(`ƒê√£ d√°n ${pastedRows.length} d√≤ng d·ªØ li·ªáu v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 3000);
                    }
                }
                updateSelectionSummary();
            });

            document.addEventListener('keydown', e => {
                const activeEl = document.activeElement;
                if (activeEl && (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl.tagName) || activeEl.isContentEditable)) {
                    return;
                }

                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const editableSelected = document.querySelectorAll('td.cell-selected.editable');
                    if (editableSelected.length > 0) {
                        e.preventDefault();

                        // Thu th·∫≠p t·∫•t c·∫£ th√¥ng tin ƒë·ªÉ x√≥a v√† map ƒë√∫ng M√£ ƒë∆°n h√†ng
                        const changesForBatchUpdate = new Map();

                        editableSelected.forEach(cell => {
                            const targetRow = cell.parentElement;
                            const orderId = targetRow.dataset.orderId;
                            if (!orderId) return;

                            const colIndex = cell.cellIndex;
                            const colName = displayColumns[colIndex];
                            const dataKey = columnMapping[colName] || colName;

                            if (!editableCols.includes(colName)) return;

                            // C·∫≠p nh·∫≠t UI
                            setCellValue(cell, '');

                            // Chu·∫©n b·ªã d·ªØ li·ªáu cho API
                            if (!changesForBatchUpdate.has(orderId)) {
                                changesForBatchUpdate.set(orderId, { [PRIMARY_KEY_COLUMN]: orderId });
                            }
                            changesForBatchUpdate.get(orderId)[dataKey] = '';
                        });

                        // G·ª≠i batch update cho vi·ªác x√≥a
                        const rowsToSend = Array.from(changesForBatchUpdate.values());
                        if (rowsToSend.length > 0) {
                            const hasTracking = hasTrackingChanges(rowsToSend);
                            batchUpdatePastedData(rowsToSend);

                            if (!hasTracking && editableSelected.length > 1) {
                                showCustomAlert(`ƒê√£ x√≥a n·ªôi dung c·ªßa ${editableSelected.length} √¥ v√† c·∫≠p nh·∫≠t ${rowsToSend.length} ƒë∆°n h√†ng.`, 'success', 2000);
                            }
                        }
                        updateSelectionSummary();
                    }
                }
            });
        }

        // M·ªöI: H√†m hi·ªÉn th·ªã popover
        function showSyncPopover() {
            const popover = document.getElementById('syncPopover');
            const body = document.getElementById('popoverBody');
            body.innerHTML = ''; // X√≥a n·ªôi dung c≈©

            const createTableHTML = (changesMap) => {
                let html = '<table class="popover-table"><thead><tr><th>M√£ ƒê∆°n H√†ng</th><th>C·ªôt Thay ƒê·ªïi</th><th>Gi√° Tr·ªã</th></tr></thead><tbody>';
                changesMap.forEach((colChanges, orderId) => {
                    colChanges.forEach((changeInfo, colName) => {
                        html += `<tr>
                            <td>${orderId}</td>
                            <td>${colName}</td>
                            <td>
                                <span class="old-value">${changeInfo.originalValue || '(tr·ªëng)'}</span>
                                <span class="new-value">${changeInfo.newValue || '(tr·ªëng)'}</span>
                            </td>
                        </tr>`;
                    });
                });
                html += '</tbody></table>';
                return html;
            };

            // Hi·ªÉn th·ªã thay ƒë·ªïi t·ª´ phi√™n tr∆∞·ªõc
            body.innerHTML += '<h5>D·ªØ li·ªáu t·ª´ phi√™n tr∆∞·ªõc (ch∆∞a ƒë∆∞·ª£c ƒë·ªìng b·ªô)</h5>';
            if (state.legacyChanges.size > 0) {
                body.innerHTML += createTableHTML(state.legacyChanges);
            } else {
                body.innerHTML += '<p class="no-changes">Kh√¥ng c√≥.</p>';
            }

            // Hi·ªÉn th·ªã thay ƒë·ªïi trong phi√™n n√†y
            body.innerHTML += '<h5 style="margin-top: 20px;">Thay ƒë·ªïi trong phi√™n n√†y</h5>';
            if (state.pendingChanges.size > 0) {
                body.innerHTML += createTableHTML(state.pendingChanges);
            } else {
                body.innerHTML += '<p class="no-changes">Kh√¥ng c√≥.</p>';
            }

            popover.style.display = 'flex';
        }

        function downloadAsExcel() {
            const allFilteredData = getFilteredData(); // L·∫•y d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c ph√¢n trang v√† l·ªçc hi·ªán t·∫°i
            if (allFilteredData.length === 0) { showCustomAlert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ t·∫£i v·ªÅ.", 'info'); return; }

            const sanitizeCsvCell = (cell, colName) => { if (cell === null || cell === undefined) return ''; let str = String(cell); if ((colName === "M√£ Tracking" || colName === "Phone*") && str) { return `="${str.replace(/"/g, '""')}"`; } if (str.includes(',') || str.includes('"') || str.includes('\n')) { str = str.replace(/"/g, '""'); return `"${str}"`; } return str; };

            const headers = displayColumns.map(col => sanitizeCsvCell(col, col)).join(',');

            const rows = allFilteredData.map(row => {
                return displayColumns.map(col => {
                    const dataKey = columnMapping[col] || col;
                    let value = row[dataKey] ?? row[col] ?? row[col.replace(/ /g, '_')] ?? '';
                    if (["Ng√†y l√™n ƒë∆°n", "Ng√†y ƒë√≥ng h√†ng"].includes(col)) { value = formatDate(value); }
                    return sanitizeCsvCell(value, col);
                }).join(',');
            }).join('\n');

            const BOM = '\uFEFF';
            const csvContent = BOM + headers + '\n' + rows;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                const today = new Date();
                const dateStr = `${today.getFullYear()}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getDate().toString().padStart(2, '0')}`;
                link.setAttribute("href", url);
                link.setAttribute("download", `BaoCaoDonHang_MGT_${dateStr}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // --- KH·ªûI T·∫†O ---
        document.addEventListener('DOMContentLoaded', () => {
            // S·ª¨A ƒê·ªîI: Kh√¥ng g·ªçi loadPendingChangesFromLocalStorage ·ªü ƒë√¢y n·ªØa
            // N√≥ s·∫Ω ƒë∆∞·ª£c g·ªçi sau khi loadData() th√†nh c√¥ng
            setupControls();
            setupInteractionHandlers();
            const rowsPerPageSelect = document.getElementById('rowsPerPageSelect');
            state.rowsPerPage = parseInt(rowsPerPageSelect.value, 10);
            loadData(); // T·∫£i d·ªØ li·ªáu l·∫ßn ƒë·∫ßu
        });
    </script>
</body>

</html>
